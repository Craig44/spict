---
title: "SPiCT"
author: "Martin W. Pedersen"
date: '`16-08-2016`'
output:
  word_document:
    toc: yes
  pdf_document:
    number_sections: yes
    toc: yes
vignette: |
  %\VignetteIndexEntry{SPiCT} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.align = 'center')
```

This vignette explains basic and more advanced functions of the `spict` package. When loading the package you are notified which version of the package you have installed:

```{r}
library(spict)
```
The printed version follows the format ver@SHA, where ver is the manually defined version number and SHA refers to a unique commit on [github](http://github.com/mawp/spict). The content of this vignette pertains to the version printed above. 

# Loading built-in example data 

The package contains the catch and index data analysed in Polacheck et al. (1993). This data can be loaded and plotted by typing

```{r}
data(pol) 
```

Data on three stocks are contained in this dataset. Here focus will be on the South Atlantic albacore data. This dataset contains the following

```{r}
pol$albacore
```

Note that data are structure in a list containing the entries `obsC` (catch observations), `timeC` (time of catch observations), `obsI` (index observations), and `timeI` (time of index observations). If times are not specified it is assumed that the first observation is observed at time 1 and then sequentially onward with a time step of one year. It is therefore recommended to always specify observation times.

# Plotting data

The data can be plotted using the command

```{r, fig.width=5, fig.height=5.5, out.width='0.5\\textwidth', fig.show='hold'}
plotspict.data(pol$albacore)
```

Note that the number of catch and index observations are given in the respective plot headers. Furthermore, note colour legend in the top-right corner, which explains at what time of the year an observation was observed based on the colour of the individual points. For illustrative purposes let's try shifting the data a bit

```{r, fig.width=5, fig.height=5.5, out.width='0.5\\textwidth', fig.show='hold'}
inpshift <- pol$albacore
inpshift$timeC <- inpshift$timeC + 0.3
inpshift$timeI <- inpshift$timeI + 0.8
plotspict.data(inpshift)
```

Now the colours show that catches are observed in the spring and index in the autumn.

# Advanced data plotting

There is also a more advanced function for plotting data, which at the same time does some basic model fitting (linear regression) and shows the results

```{r, results='show', message=FALSE, warning=FALSE, fig.width=6.5, fig.height=5.5, fig.show='hold'}
plotspict.ci(pol$albacore)
```

The two top plots come from `plotspict.data`, with the dashed horizontal line representing a guess of MSY. This guess comes from a linear regression between the index and the catch divided by the index (middle row, left). This regression is expected to have a negative slope. A similar plot can be made showing catch versus catch/index (middle row, right) to approximatively find the optimal effort (or effort proxy). The proportional increase in the index as a function of catch (bottom row, right) should show primarily positive increases in index at low catches and vice versa. Positive increases in index at large catches could indicate model violations. In the current plot these are not seen.

# Fitting the model

Let's try to fit the model to the data

```{r, results='show', message=FALSE, warning=FALSE, fig.width=6.5, fig.height=5.5, fig.show='hold'}
inp <- pol$albacore
inp$timepredc <- 1993 # Prediction horizon for catches
system.time(rep <- fit.spict(inp))
```

The call to `fit.spict` is wrapped in the `system.time` command to check the time spent on the calculations. This is obviously not required, but done here to show that fitting the model only takes a few seconds. The result of the model fit is stored in `rep`, which can either be plotted using `plot` or summarised using `summary`. 

# Interpreting the plot of results

The results are plotted using

```{r, results='show', message=FALSE, warning=FALSE, fig.width=6.5, fig.height=5.5, fig.show='hold'}
plot(rep)
```

Some general comments can be made regarding the style and colours of these plots:

- Estimates (biomass, fishing mortality, catch, production) are shown using blue lines.
- 95% CIs of absolute quantities are shown using dashed blue lines.
- 95% CIs of relative biomass and fishing mortality are shown using shaded blue regions.
- Estimates of reference points ($B_{MSY}$, $F_{MSY}$, $MSY$) are shown using black lines.
- 95% CIs of reference points are shown using grey shaded regions.
- The end of the data range is shown using a vertical grey line.
- Predictions beyond the data range are shown using dotted blue lines.
- Data are shown using points coloured by season. Different index series use different point characters (not shown here).

The individual plots can be plotted separately. We will now look at them one at a time. The top left is the plot of absolute biomass

```{r, results='show', message=FALSE, warning=FALSE, fig.width=4, fig.height=4, fig.show='hold'}
plotspict.biomass(rep)
```

Note that this plot has a y-axis on the right side related to the relative biomass ($B_t/B_{MSY}$). The shaded 95% CI region relates to this axis, while the dashed blue lines relate to the left y-axis indicating absolute levels. The dashed lines and the shaded region are shown on the same plot to make it easier to assess whether the relative or absolute levels are most accurately estimated. Here, the absolute are more accurate than the relative. Later, we will see examples of the opposite. The horizontal black line is the estimate of $B_{MSY}$ with 95% CI shown as a grey region.

The plot of the relative biomass is produced using

```{r, results='show', message=FALSE, warning=FALSE, fig.width=4, fig.height=4, fig.show='hold'}
plotspict.bbmsy(rep)
```

This plot contains much of the same information as given by `plotspict.biomass`, but without the information about absolute biomass and without the 95% CI around the $B_{MSY}$ reference point.

The plots of fishing mortality follow the same principles

```{r, results='show', message=FALSE, warning=FALSE, fig.width=3, fig.height=3.3, fig.show='hold'}
plotspict.f(rep, main='', qlegend=FALSE, rel.axes=FALSE, rel.ci=FALSE)
plotspict.ffmsy(rep, main='', qlegend=FALSE)
```

The estimate of $F_{MSY}$ is shown with a horizontal black line with 95% CI shown as a grey region (left plot). The 95% CI of $F_{MSY}$ is very wide in this case. As shown here it is quite straightforward to remove the information about relative levels from the plot of absolute fishing mortality. Furthermore, the argument `main=''` removes the heading and `qlegend=FALSE` removes the colour legend for data points.

The plot of the catch is produced using

```{r, results='show', message=FALSE, warning=FALSE, fig.width=4, fig.height=4, fig.show='hold'}
plotspict.catch(rep)
```

This plot shows estimated catches (blue line) versus observed catches (points) with the estimate of $MSY$ plotted as a horizontal black line with its 95% CI given by the grey region.

# Setting initial parameter values

## Checking robustness to initial parameter values

# How to fix parameters using estimation phases

# Priors

# Seasonality

# Extracting estimates

get.par()

# Robust estimation (reducing influence of outliers)

Estimation becomes less stable

Perhaps fix some parameters

# Simulation

# Forecasting

To make a catch forecast a forecast interval needs to be specified. This is done by specifying the start of the interval (`inp$timepredc`) and the length of the interval in years (`inp$dtpredc`). In addition to the forecast interval a fishing scenario needs to be specified. This is done by specifying a factor (`inp$ffac`) to multiply the current fishing mortality by (i.e. the F at the last time point of the time period where data are available) and the time that management should start (`inp$manstart`). The time point of the reported forecast of biomass and fishing mortality can be controlled by setting `inp$timepredi`. Producing short-term forecasts entails minimal additional computing time.

Forecasts are produced as part of the usual model fitting. To illustrate the procedure, a short example using the South Atlantic albacore dataset of Polacheck et al. (1993) containing catch and commercial CPUE data in the interval 1967 to 1989 is presented. The code to obtain the forecasted annual catch in the interval starting 1991 under a management scenario where the fishing pressure is reduced by 25% starting in 1991, and a forecasted index in 1992 is:

```{r, results='show', message=FALSE, warning=FALSE, fig.width=4, fig.height=4, fig.show='hold'}
library(spict)
data(pol)
inp <- pol$albacore
inp$manstart <- 1991
inp$timepredc <- 1991
inp$dtpredc <- 1
inp$timepredi <- 1992
inp$ffac <- 0.75
rep <- fit.spict(inp)
```

To specifically show forecast results use

```{r, results='show', message=FALSE, warning=FALSE, fig.width=4, fig.height=4, fig.show='hold'}
sumspict.predictions(rep)
```

This output is also shown when using `summary(rep)`. The results can be plotted using `plot(rep)`, however to visualise the change in forecasted fishing mortality and associated change in forecasted catch more clearly we use

```{r, results='show', message=FALSE, warning=FALSE, fig.width=6.5, fig.height=5.5, fig.show='hold'}
par(mfrow=c(2, 2), mar=c(4, 4.5, 3, 3.5))
plotspict.bbmsy(rep, stamp='')
plotspict.ffmsy(rep, qlegend=FALSE, stamp='')
plotspict.catch(rep, qlegend=FALSE, stamp='')
plotspict.fb(rep, man.legend=FALSE, stamp='')
```

Note in the plot that the decrease in fishing pressure results in a constant biomass as opposed to the expected decrease if fishing effort had remained constant.

SPiCT has a function that runs several predefined management scenarios, which can be presented in a forecast table. To perform the calculations required to produce the forecast table run:

```{r, results='show', message=FALSE, warning=FALSE, fig.width=4, fig.height=4, fig.show='hold'}
rep <- manage(rep)
```

where `rep` is the result of `fit.spict()` from the code above. Then, the results can be summarised (and extracted) by running:

```{r, results='show', message=FALSE, warning=FALSE, fig.width=4, fig.height=4, fig.show='hold'}
df <- mansummary(rep)
```

Then, `df` is a data frame with each line containing a line of the output

```{r, results='show', message=FALSE, warning=FALSE, fig.width=4, fig.height=4, fig.show='hold'}
head(df)
```

The resulting biomass, fishing mortality and catch of the management scenarios are included in the standard plots

```{r, results='show', message=FALSE, warning=FALSE, fig.width=6.5, fig.height=5.5, fig.show='hold'}
par(mfrow=c(2, 2), mar=c(4, 4.5, 3, 3.5))
plotspict.bbmsy(rep, stamp='')
plotspict.ffmsy(rep, qlegend=FALSE, stamp='')
plotspict.catch(rep, qlegend=FALSE, stamp='')
plotspict.fb(rep, man.legend=FALSE, stamp='')
```




## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))

#' @name predict.b
#' @title Helper function for sim.spict().
#' @param B0 Initial biomass.
#' @param F0 Fishing mortality.
#' @param gamma gamma parameter in Fletcher's Pella-Tomlinson formulation.
#' @param m m parameter in Fletcher's Pella-Tomlinson formulation.
#' @param K Carrying capacity.
#' @param n Pella-Tomlinson exponent.
#' @param dt Time step.
#' @param sdb Standard deviation of biomass process.
#' @return Predicted biomass at the end of dt.
predict.b <- function(B0, F0, gamma, m, K, n, dt, sdb){
    #return(exp( log(B0) + (rate - r*(B0/K)^p)*dt )) # Euler
    exp( log(B0) + (gamma*m/K - gamma*m/K*(B0/K)^(n-1.0) - F0 - 0.5*sdb^2)*dt )
}


#' @name sim.spict
#' @title Simulate data from Pella-Tomlinson model
#' @details Simulates data using either manually specified parameters values or parameters estimated by fit.spict().
#'
#' Manual specification:
#' To specify parameters manually use the inp$ini format similar to when specifying initial values for running fit.spict(). Observations can be simulated at specific times using inp$timeC and inp$timeI. If these are not specified then the length of inp$obsC or inp$obsI is used to determine the number of observations of catches and indices respectively. If none of these are specified then nobs observations of catch and index will be simulated evenly distributed in time.
#'
#' Estimated parameters:
#' Simply take the output from a fit.spict() run and use as input to sim.spict().
#' 
#' @param input Either an inp list with an ini key (see ?check.inp) or a rep list where rep is the output of running fit.spict().
#' @param nobs Optional specification of the number of simulated observations.
#' @return A list containing the simulated data.
#' @examples
#' data(pol)
#' # Simulate a specific number of observations
#' inp <- pol$albacore
#' inp$obsC <- NULL
#' inp$timeC <- NULL
#' inp$obsI <- NULL
#' inp$timeI <- NULL
#' set.seed(1)
#' sim <- sim.spict(inp, nobs=150)
#' repsim <- fit.spict(sim)
#' summary(repsim) # Note true values are listed in the summary
#' dev.new(width=10, height=10)
#' plot(repsim) # Note true states are shown with orange colour
#'
#' # Simulate data with seasonal F
#' inp <- list()
#' inp$dteuler <- 1/4
#' inp$nseasons <- 2
#' inp$splineorder <- 1
#' inp$obsC <- 1:80
#' inp$obsI <- 1:80
#' inp$ini <- pol$albacore$ini
#' inp$ini$logphi <- log(2) # Seasonality introduced here
#' inp <- check.inp(inp)
#' sim2 <- sim.spict(inp)
#' par(mfrow=c(2, 1))
#' plot(sim2$obsC, typ='l')
#' plot(sim2$obsI[[1]], typ='l')
#' @export
sim.spict <- function(input, nobs=100){
    # Check if input is a inp (initial values) or rep (results).
    if('par.fixed' %in% names(input)){
        cat('Detected input as a SPiCT result, proceeding...\n')
        rep <- input
        inp <- rep$inp
        pl <- rep$pl
        plin <- inp$ini
    } else {
        if('ini' %in% names(input)){
            cat('Detected input as a SPiCT inp, proceeding...\n')
            inp <- input
            nm <- names(inp)
            if(!'timeC' %in% nm){
                if(!'obsC' %in% nm){
                    inp$nobsC <- nobs
                } else {
                    inp$nobsC <- length(inp$obsC)
                }
                inp$timeC <- 1:inp$nobsC
            } else {
                inp$nobsC <- length(inp$timeC)
            }
            if(!'obsC' %in% nm) inp$obsC <- rep(10, inp$nobsC) # Insert dummy, required by check.inp().
            if(!'logq' %in% names(inp$ini)) stop('logq not specified in inp$ini!')
            inp$nindex <- length(inp$ini$logq)
            if(!'timeI' %in% nm){
                if(!'obsI' %in% nm){
                    inp$nobsI <- nobs
                } else {
                    if(class(inp$obsI)!='list'){
                        tmp <- inp$obsI
                        inp$obsI <- list()
                        inp$obsI[[1]] <- tmp
                    }
                    inp$nobsI <- rep(0, inp$nindex)
                    for(i in 1:inp$nindex) inp$nobsI[i] <- length(inp$obsI[[i]])
                }
                inp$timeI <- list()
                for(i in 1:inp$nindex) inp$timeI[[i]] <- 1:inp$nobsI[i]
            } else {
                inp$nobsI <- rep(0, inp$nindex)
                for(i in 1:inp$nindex) inp$nobsI[i] <- length(inp$timeI[[i]])
            }
            if(!'obsI' %in% nm){
                inp$obsI <- list()
                for(i in 1:inp$nindex) inp$obsI[[i]] <- rep(10, inp$nobsI[i]) # Insert dummy
            }
            plin <- inp$ini
            inp <- check.inp(inp)
            pl <- inp$parlist
        } else {
            stop('Invalid input! use either an inp list or a fit.spict() result.')
        }
    }
    time <- inp$time
    euler <- inp$euler
    lamperti <- inp$lamperti

    # Calculate derived variables
    dt <- inp$dteuler
    nt <- length(time)
    if('logbkfrac' %in% names(inp$ini)){
        B0 <- exp(inp$ini$logbkfrac)*exp(pl$logK)
    } else {
        B0 <- 0.8*exp(pl$logK)
    }
    if('logF0' %in% names(inp$ini)){
        F0 <- exp(inp$ini$logF0)
    } else {
        F0 <- 0.2*exp(inp$ini$logr)
    }
    m <- exp(pl$logm)
    n <- exp(pl$logn)
    gamma <- calc.gamma(n)
    K <- exp(pl$logK)
    q <- exp(pl$logq)
    logphi <- pl$logphi
    sdb <- exp(pl$logsdb)
    sdf <- exp(pl$logsdf)
    alpha <- exp(pl$logalpha)
    beta <- exp(pl$logbeta)
    sdi <- alpha * sdb
    sdc <- beta * sdf

    # B[t] is biomass at the beginning of the time interval starting at time t
    # I[t] is an index of biomass (e.g. CPUE) at the beginning of the time interval starting at time t
    # P[t] is the accumulated biomass production over the interval starting at time t
    # F[t] is the constant fishing mortality during the interval starting at time t
    # C[t] is the catch removed during the interval starting at time t. 
    # obsC[j] is the catch removed over the interval starting at time j, this will typically be the accumulated catch over the year.

    # - Fishing mortality -
    seasonspline <- get.spline(pl$logphi, order=inp$splineorder, dtfine=dt)
    nseasonspline <- length(seasonspline)
    flag <- TRUE
    recount <- 0
    while(flag){
        #ef <- rnorm(nt-1, 0, sdf*sqrt(dt))
        ef <- arima.sim(inp$armalistF, nt-1) * sdf*sqrt(dt) # Used to simulate other than white noise in F
        Fbase <- c(F0, exp(log(F0) + cumsum(ef))) # Fishing mortality
        F <- numeric(length(Fbase))
        for(i in 1:nseasonspline){
            inds <- which(inp$seasonindex==(i-1))
            F[inds] <- Fbase[inds] * exp(seasonspline[i])
        }
        #F <- c(F0, exp(log(F0) + cumsum(rnorm(nt-1, 0, sdf*sqrt(dt))))) # Fishing mortality
        # - B_infinity
        #Binf <- rep(0,nt)
        #for(t in 1:nt) Binf[t] <- calc.binf(K, F[t], r[inp$ir[t]], p, sdb, lamperti)
        # - Biomass -
        B <- rep(0,nt)
        B[1] <- B0
        e <- exp(rnorm(nt-1, 0, sdb*sqrt(dt)))
        
        #for(t in 2:nt) B[t] <- predict.b(B[t-1], Binf[t-1], F[t-1], r[inp$ir[t]], p, K, dt, sdb, lamperti, euler) * e[t-1]
        for(t in 2:nt) B[t] <- predict.b(B[t-1], F[t-1], gamma, m[inp$ir[t]], K, n, dt, sdb) * e[t-1]
        flag <- any(B <= 0) # Negative biomass not allowed
        recount <- recount+1
        if(recount > 10) stop('Having problems simulating data where B > 0, check parameter values!')
    }
    # - Catch -
    Csub <- rep(0,nt)
    for(t in 1:nt) Csub[t] <- F[t]*B[t]*dt
    # - Production -
    Psub <- rep(0,nt)
    for(t in 2:nt) Psub[t-1] <- B[t] - B[t-1] + Csub[t-1]
    # - Catch observations -
    C <- rep(0, inp$nobsC)
    obsC <- rep(0, inp$nobsC)
    for(i in 1:inp$nobsC){
        for(j in 1:inp$nc[i]){
            ind <- inp$ic[i] + j-1
            C[i] <- C[i] + Csub[ind];
        }
        obsC[i] <- exp(log(C[i]) + rnorm(1, 0, sdc))
    }
    if('outliers' %in% names(inp)){
        if('noutC' %in% names(inp$outliers)){
            #if(!'facoutC' %in% names(inp$outliers)) inp$outliers$facoutC <- 20
            fac <- invlogp1(inp$ini$logp1robfac)
            inp$outliers$orgobsC <- obsC
            inp$outliers$indsoutC <- sample(1:inp$nobsC, inp$outliers$noutC)
            obsC[inp$outliers$indsoutC] <- exp(log(obsC[inp$outliers$indsoutC]) + rnorm(inp$outliers$noutC, 0, fac*sdc))
        }
    }
    # - Index observations -
    obsI <- list()
    errI <- list()
    for(I in 1:inp$nindex){
        obsI[[I]] <- rep(0, inp$nobsI[I])
        errI[[I]] <- rep(0, inp$nobsI[I])
        for(i in 1:inp$nobsI[I]){
            errI[[I]][i] <- rnorm(1, 0, sdi)
            logItrue <- log(q[I]) + log(B[inp$ii[[I]][i]])
            obsI[[I]][i] <- exp(logItrue + errI[[I]][i])
        }
    }
    if('outliers' %in% names(inp)){
        if('noutI' %in% names(inp$outliers)){
            if(length(inp$outliers$noutI)==1) inp$outliers$noutI <- rep(inp$outliers$noutI, inp$nindex)
            #if(!'facoutI' %in% names(inp$outliers)) inp$outliers$facoutI <- 20
            fac <- invlogp1(inp$ini$logp1robfac)
            #if(length(inp$outliers$facoutI)==1) inp$outliers$facoutI <- rep(inp$outliers$facoutI, inp$nindex)
            inp$outliers$orgobsI <- obsI
            inp$outliers$indsoutI <- list()
            for(i in 1:inp$nindex){
                inp$outliers$indsoutI[[i]] <- sample(1:inp$nobsI[i], inp$outliers$noutI[i])
                obsI[[i]][inp$outliers$indsoutI[[i]]] <- exp(log(obsI[[i]][inp$outliers$indsoutI[[i]]]) + rnorm(inp$outliers$noutI[i], 0, fac*sdi))
            }
        }
    }
    
    sim <- list()
    sim$obsC <- obsC
    sim$timeC <- inp$timeC
    sim$obsI <- obsI
    sim$timeI <- inp$timeI
    sim$ini <- plin #list(logr=log(r), logK=log(K), logq=log(q), logsdf=log(sdf), logsdb=log(sdb))
    sim$do.sd.report <- inp$do.sd.report
    sim$reportall <- inp$reportall
    sim$dteuler <- inp$dteuler
    sim$splineorder <- inp$splineorder
    sim$euler <- inp$euler
    sim$lamperti <- inp$lamperti
    sim$phases <- inp$phases
    sim$outliers <- inp$outliers
    sim$recount <- recount
    sim$true <- pl
    sim$true$dteuler <- inp$dteuler
    sim$true$splineorder <- inp$splineorder
    sim$true$time <- time
    sim$true$B <- B
    sim$true$F <- Fbase
    sim$true$Fs <- F
    sim$true$gamma <- gamma
    
    sign <- 1
    #print(inp$ir)
    #print(paste(n, gamma, m, mean(m[inp$ir]), K))
    R <- (n-1)/n*gamma*mean(m[inp$ir])/K
    p <- n-1
    sim$true$R <- R
    # Deterministic reference points
    sim$true$Bmsyd <- K/(n^(1/(n-1)))
    sim$true$MSYd <- mean(m[inp$ir])
    sim$true$Fmsyd <- sim$true$MSYd/sim$true$Bmsyd
    # From Bordet & Rivest (2014)
    sim$true$Bmsy <- K/(p+1)^(1/p) * (1- (1+R*(p-1)/2)/(R*(2-R)^2)*sdb^2)
    sim$true$Fmsy <- R - p*(1-R)*sdb^2/((2-R)^2)
    sim$true$MSY <- K*R/((p+1)^(1/p)) * (1 - (p+1)/2*sdb^2/(1-(1-R)^2))
    sim$true$BBmsy <- B/sim$true$Bmsy
    sim$true$FFmsy <- F/sim$true$Fmsy
    #sim$true$Bmsy <- sim$true$Bmsyd * (1 - (1+R*(p-1)/2)*sdb^2 / (R*(2-R)^2))
    #sim$true$Fmsy <- sim$true$Fmsyd - (p*(1-R)*sdb^2) / ((2-R)^2)
    #sim$true$MSY <- sim$true$MSYd * (1 - ((p+1)/2*sdb^2) / (1-(1-R)^2))
    sim$true$errI <- errI
    sim$true$logB <- NULL
    sim$true$logF <- NULL
    return(sim)
}

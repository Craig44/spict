#' @exportClass spictcls
setClass("spictcls")


#' @useDynLib spict
.onUnload <- function (lib) {
  library.dynam.unload("spict", lib)
}


#' @name pol
#' @title Fisheries data included in Polacheck et al. (1993).
#' @details Fisheries data for south Atlantic albacore, northern Namibian hake, and New Zealand rock lobster.
#' @docType data
#' @keywords datasets
#' @usage data(pol)
#' @source Polacheck et al. (1993), Canadian Journal of Fisheries and Aquatic Science, vol 50, pp. 2597-2607.
#' @examples
#' data(pol)
#' rep <- fit.spict(inp=pol$albacore)
#' rep <- fit.spict(inp=pol$hake)
#' rep <- fit.spict(inp=pol$lobster)
#' @format Data are lists containing data and initial values for estimation formatted to be used as an input to fit.spict().
NULL


#' @name test.spict
#' @title Example of a spict analysis.
#' @details Loads a data set, fits the model, calculates one-step-ahead residuals, plots the results.
#' @param dataset Specify one of the three test data sets: 'albacore', 'hake', 'lobster'. These can be accessed with the command data(pol).
#' @return A result report as given by fit.spict().
#' @examples
#' rep <- test.spict()
#' @export
test.spict <- function(dataset='albacore'){
    # Load data
    data(pol)
    inp <- pol[[dataset]]
    if(dataset=='albacore'){
        inp$ffac <- 0.9
        nopredcyears <- 6 # Number of years to predict catch
        inp$dtpredc <- 1 # Time step when predicting catch
        inp$timepredi <- tail(inp$timeC, 1) + nopredcyears
        inp$timepredc <- tail(inp$timeC, 1) + nopredcyears
    }
    # Fit model
    rep <- fit.spict(inp)
    # Calculate one-step-ahead residuals
    rep <- calc.osa.resid(rep)
    # Plot results
    graphics.off()
    dev.new(width=10, height=10)
    plot(rep)
    summary(rep)
    return(rep)
}


#' @name calc.gamma
#' @title Calculate gamma from n
#' @export
calc.gamma <- function(n) n^(n/(n-1)) / (n-1)


#' @name get.par
#' @title Extract parameters from a result report as generated by fit.spict.
#' @details Helper function for extracting the value and uncertainty of a specific model parameter, random effect or derived quantity.
#' @param parname Character string containing the name of the variable of interest.
#' @param rep A result report as generated by running fit.spict.
#' @param exp Take exp of the variable? TRUE/FALSE.
#' @param random DUMMY not used anymore. (Is the variable a random effect? TRUE/FALSE.)
#' @param fixed DUMMY not used anymore. (Is the variable a fixed effect? TRUE/FALSE.)
#' @return A matrix with four columns containing respectively: 1) the lower 95% confidence limit; 2) the parameter estimate; 3) the upper 95% confidence limit; 4) the parameter standard deviation in the domain it was estimated (log or non-log).
#' @export
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' Bmsy <- get.par('logBmsy', rep, exp=TRUE)
#' Best <- get.par('logB', rep, exp=TRUE)
#' K <- get.par('logK', rep, exp=TRUE)
get.par <- function(parname, rep=rep, exp=FALSE, random=FALSE, fixed=FALSE){
    if(!'sderr' %in% names(rep)){
        indran <- which(names(rep$par.random)==parname)
        indfix <- which(names(rep$par.fixed)==parname)
        indsdr <- which(names(rep$value)==parname)
        indopt <- which(names(rep$opt$par)==parname)
        est <- NULL
        if(length(indran)>0){
            est <- rep$par.random[indran]
            sd <- sqrt(rep$diag.cov.random[indran])
            ll <- est - 1.96*sd
            ul <- est + 1.96*sd
        }
        if(length(indfix)>0){
            est <- rep$par.fixed[indfix]
            sd <- sqrt(diag(rep$cov.fixed))[indfix]
            ll <- est - 1.96*sd
            ul <- est + 1.96*sd
        }
        if(length(indsdr)>0){
            est <- rep$value[indsdr]
            sd <- rep$sd[indsdr]
            ll <- est - 1.96*sd
            ul <- est + 1.96*sd
        }
        if(length(est)==0){
            ll <- NA
            ul <- NA
            sd <- NA
            est <- NA
            if(length(indopt)>0){
                est <- rep$opt$par[indopt]
            } else {
                if('phases' %in% names(rep$inp)){
                    if(parname %in% names(rep$inp$phases)){
                        if(rep$inp$phases[[parname]] == -1){
                            #cat(paste('WARNING: did not estimate', parname, 'extracting fixed initial value.\n'))
                            est <- rep$inp$parlist[[parname]]
                            ll <- est
                            ul <- est
                        }
                    }else {
                        if(parname == 'P'){
                            B <- get.par('logB', rep, exp=TRUE)
                            C <- get.par('logCpred', rep, exp=TRUE)
                            ic <- rep$inp$ic
                            nc <- rep$inp$nc
                            B0 <- B[ic, 2]
                            B1 <- B[ic+nc, 2]
                            est <- B1 - B0 + C[, 2]
                            #if(rep$inp$dtpredc <= 0) C <- C[-dim(C)[1], ]
                            #nn <- 1/rep$inp$dteuler
                            #mm <- dim(C)[1]
                            #inds <- 1:(nn*mm+1)
                            #Bs <- apply(matrix(diff(B[inds, 2]), nn, mm), 2, sum)
                            #est <- Bs + C[, 2]
                        }
                    }
                } else {
                    cat(paste('get.par WARNING: could not extract', parname, '\n'))
                }
            }
        }
        if(exp==TRUE){
            cv <- sqrt(exp(sd^2) - 1)
        } else {
            cv <- sd/est
        }
        if(exp){
            return(cbind(ll=exp(ll), est=exp(est), ul=exp(ul), sd, cv))
        } else {
            return(cbind(ll, est, ul, sd, cv))
        }
    }
}


#' @name get.msyvec
#' @title If multiple growth rates (r) are used (e.g. for a seasonal model), return specified reference point for all instances of r.
#' @param inp An input list as validated by check.inp().
#' @param msy Matrix containing reference point values as given by get.par().
#' @return A list containing reference point estimates with upper and lower CI bounds.
get.msyvec <- function(inp, msy){
    vec <- rep(0, inp$ns)
    ul <- rep(0, inp$ns)
    ll <- rep(0, inp$ns)
    nr <- length(inp$ini$logr)
    for(i in 1:nr){
        vec[inp$ir==i] <- msy[i, 2]
        ul[inp$ir==i] <- msy[i, 3]
        ll[inp$ir==i] <- msy[i, 1]
    }
    return(list(msy=vec, ll=ll, ul=ul))
}


#' @name make.splinemat
#' @title Make a spline design matrix
#' @param nseasons Number of seasons
#' @param order Order of the spline
#' @param dtfine Time between points where spline is evaluated
#' @return Spline design matrix.
#' @export
make.splinemat <- function(nseasons, order, dtfine=1/100){
    if(dtfine==1){
        d <- matrix(1, 1, 1)
    } else {
        dtspl <- 1/nseasons
        knots <- seq(0, 1, by=dtspl)
        x <- seq(0, 1-dtfine, by=dtfine)
        if(order > 1){
            require(mgcv)
            d <- cSplineDes(x, knots, ord=order)
        } else {
            if(order < 1){
                cat('WARNING: specified spline order (', order, ') not valid!')
                order <- 1
            }
            nx <- length(x)
            nknots <- length(knots)
            d <- matrix(0, nx, nknots-1)
            for(i in 1:(nknots-1)){
                inds <- which(x >= knots[i] & x < knots[i+1])
                d[inds, i] <- 1
            }
        }
    }
    return(d)
}


#' @name get.spline
#' @title Get the values of the seasonal spline for F
#' @param logphi Values of the phi vector
#' @param order Order of the spline
#' @param dtfine Time between points where spline is evaluated
#' @return Spline values at the points between 0 and 1 with dtfine as time step.
#' @export
get.spline <- function(logphi, order, dtfine=1/100){
    logphipar <- c(0, logphi)
    nseasons <- length(logphipar)
    d <- make.splinemat(nseasons, order, dtfine)
    spline <- as.vector(d %*% logphipar)
    return(spline)
}


#' @name get.AIC
#' @title Calculate AIC from a rep list.
#' @param rep 
#' @return AIC
#' @export
get.AIC <- function(rep){
    negloglik <- rep$opt$objective
    numpars <- length(rep$opt$par)
    AIC <- 2*numpars + 2*negloglik
    return(AIC)
}


#' @name invlogit
#' @title Inverse logit transform.
#' @param a Value to take inverse logit of.
#' @return Inverse logit.
invlogit <- function(a) 1/(1+exp(-a))


#' @name invlogp1
#' @title Inverse log "plus one" transform
#' @details If a = log(b-1), then the inverse transform is b = 1 + exp(a). Useful for values with lower bound at 1.
#' @param a Value to take inverse logp1 of.
#' @return Inverse logp1.
invlogp1 <- function(a) 1 + exp(a)


#' @name guess.m
#' @title Use a simple linear regression to guess m (MSY).
#' @details Equations 9.1.7 and 9.1.8 on page 284 of FAO's tropical assessment book are used to guess MSY.
#' @param inp An input list containing data.
#' @param Emsy.return If true also return a guess on Emsy (effort at MSY) and components of the linear regression.
#' @return The guess on MSY.
#' @export
guess.m <- function(inp, all.return=FALSE){
    y <- inp$obsC
    if(class(inp$obsI)=='list'){
        z <- inp$obsI[[1]]
    } else {
        z <- inp$obsI
    }
    if(length(y) == length(z)){
        x <- y/z
        mod0 <- lm(z ~ x)
        a <- mod0$coefficients[1]
        b <- mod0$coefficients[2]
        MSY <- -0.25*a^2/b # p. 284 in FAO's book on tropical stock assessment
        if(MSY <= 0) MSY <- mean(y) # Mean catch
        if(Emsy.return){
            Emsy <- -0.5*a/b # p. 284 in FAO's book on tropical stock assessment
            return(list(MSY=MSY, Emsy=Emsy, a=a, b=b, x=x, y=y, z=z, mod0=mod0))
        } else {
            return(MSY)
        }
    } else {
        return(mean(y))
    }
}

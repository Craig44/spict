
#' @name arrow.line
#' @title Draw a line with arrow heads.
#' @details Add to an existing plot a continuous line with arrow heads showing the direction between each data point
#' @param x X coordinates.
#' @param y Y coordinates.
#' @param length See documentation for arrows.
#' @param angle See documentation for arrows.
#' @param code See documentation for arrows.
#' @param col See documentation for arrows.
#' @param lty See documentation for arrows.
#' @param lwd See documentation for arrows.
#' @param ... See documentation for arrows.
#' @return Nothing, but an arrow line is added to the current plot.
arrow.line <- function(x, y, length = 0.25, angle = 30, code = 2, col = par("fg"), lty = par("lty"), lwd = par("lwd"), ...){
    n <- length(x)
    for(i in 2:n) arrows(x[i-1], y[i-1], x[i], y[i], length, angle, code, col, lty, lwd, ...)
}


#' @name annual
#' @title Convert from quarterly (or other sub-annual) data to annual means or sums.
#' @param intime A time vector corresponding to the values in vec.
#' @param vec The vector of values to convert to annual means
#' @param type If type='mean' then annual mean is calculated, if type='sum' then annual sum is calculated.
#' @return A list containing the annual means and a corresponding time vector.
annual <- function(intime, vec, type='mean'){
    anntime <- intime[which(intime %% 1 ==0)]
    nanntime <- length(anntime)
    nstepvec <- rep(0, nanntime)
    floortime <- floor(intime)
    for(i in 1:nanntime) nstepvec[i] <- sum(anntime[i]==floortime)
    nsteps <- max(nstepvec)
    # Remove years that are not full
    anntime <- anntime[which(nstepvec==max(nstepvec))]
    nanntime <- length(anntime)
    annvec <- rep(0, nanntime)
    for(i in 1:nanntime){
        inds <- which(anntime[i]==floortime)
        if(type=='mean'){
            annvec[i] <- mean(vec[inds])
        }
        if(type=='sum'){
            annvec[i] <- sum(vec[inds])
        }
    }
    return(list(anntime=anntime, annvec=annvec))
}


#' @name refpointci
#' @title Draw CI around a reference point using polygon
#' @param t Time vector.
#' @param ll Lower limit.
#' @param ul Upper limit.
#' @param cicol Colour of polygon
#' @return Spline design matrix.
refpointci <- function(t, ll, ul, cicol='ivory2'){
    tplus <- c(t[1]*0.8, t, tail(t, 1)*1.2)
    llplus <- c(ll[1], ll, tail(ll, 1))
    ulplus <- c(ul[1], ul, tail(ul, 1))
    polygon(c(tplus, rev(tplus)), c(llplus, rev(ulplus)), col=cicol, border=cicol)
}


#' @name make.ellipse
#' @title Calculate confidence ellipsis.
#' @details Calculates the confidence ellipsis of two reported model parameters. This is particularly useful as a detailed view of the uncertainty of two correlated parameters.
#' @param inds Indices of the two reported model parameters.
#' @param rep A result report as generated by running fit.spict.
#' @return A matrix with two columns containing the x and y coordinates of the ellipsis.
make.ellipse <- function(inds, rep){
    require(ellipse)
    covBF <- rep$cov[inds,inds]
    corBF <- cov2cor(covBF)
    parBF <- rep$value[inds]
    return(ellipse(corBF[1,2], scale=sqrt(diag(covBF)), centre=parBF, npoints=300))
}


#' @name season.cols
#' @title Load season colors.
#' @return Vector containing season colors.
season.cols <- function() rep(c(4, 3, 2, 5, 1, 6, 7, 'orange'), 10) # Make sure we have enough colors


#' @name plot.col
#' @title Plot model points colored depending on the quarter to which they belong.
#' @param time Time vector
#' @param obs Observation vector (or residual vector).
#' @param pch Point character.
#' @param add If TRUE plot is added to the current plot.
#' @param typ Plot type.
#' @param ... Additional plotting arguments.
#' @return Nothing.
plot.col <- function(time, obs, pch=1, add=FALSE, typ='p', do.line=TRUE, add.legend=FALSE, ...){
    cols <- season.cols()
    nintv <- 4
    intvs <- seq(0, length=nintv, by=1/nintv)
    mods <- time%%1
    if(!add) plot(time, obs, xlab='Time', typ='n', ...)
    if(typ=='p' & do.line) lines(time, obs, col='lightgray')
    for(i in 1:nintv){
        inds <- which(mods >= intvs[i] & mods < (intvs[i]+1/nintv))
        if(typ=='p') points(time[inds], obs[inds], col=1, pch=20+pch, bg=cols[i])
        if(typ=='l') lines(time[inds], obs[inds], col=cols[i], lty=1)
    }
    if(add.legend) add.col.legend(nintv, cols, pch=1)
    if(!add) box(lwd=1.5)
}


#' @name add.col.legend
#' @title Add a legend indicating point colors of quarters.
#' @param nintv Number of intervals.
#' @param cols Vector containing colors.
#' @param pch Point character.
#' @return Nothing.
add.col.legend <- function(nintv, cols, pch=1){
    par(xpd=TRUE)        
    sp <- 0.02
    xx <- grconvertX(sp, 'nfc', 'user')
    spyy <- 1-2*sp
    dy <- 0.04
    for(i in 1:nintv){
        yy <- grconvertY(spyy-(i-1)*dy, 'nfc', 'user')
        points(xx, yy, pch=20+pch, col=1, bg=cols[i])
        text(xx, yy, paste0('Q', i), pos=4)
    }
    par(xpd=FALSE)
}


#' #' @name plotspict.biomass
#' @title Plot estimated biomass.
#' @details Plots estimated biomass, Bmsy with confidence limits.
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of y-axis? default: FALSE
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.biomass(rep)
#' @export
plotspict.biomass <- function(rep, logax=FALSE, main=-1, plot.legend=TRUE, ylim=NULL, plot.obs=TRUE, qlegend=TRUE){
    if(!'sderr' %in% names(rep)){
        log <- ifelse(logax, 'y', '')
        inp <- rep$inp
        # Biomass plot
        Best <- get.par('logB', rep, exp=TRUE, random=TRUE)
        ns <- dim(Best)[1]
        Kest <- get.par('logK', rep, exp=TRUE, fixed=TRUE)
        Bmsy <- get.par('logBmsy', rep, exp=TRUE)
        Bmsyvec <- get.msyvec(inp, Bmsy)
        #Binf <- get.par('logBinf', rep, exp=TRUE)
        qest <- get.par('logq', rep, exp=TRUE)
        BB <- get.par('logBBmsy', rep, exp=TRUE)
        #inds <- which(is.na(Binf) | Binf<0)
        #Binf[inds] <- 1e-12
        #annlist <- annual(inp$time, Binf[, 2])
        #Binftime <- annlist$anntime
        #Binfs <- annlist$annvec
        Bp <- get.par('logBp', rep, exp=TRUE)
        scal <- 1
        cicol <- 'lightgray'
        #cicol <- 'ivory2'
        obsI <- list()
        for(i in 1:inp$nindex) obsI[[i]] <- inp$obsI[[i]]/qest[i, 2]
        #par(mar=c(5,4,4,4))
        #fininds <- which(apply(Best, 1, function(x) all(abs(x) < 1e8)))
        fininds <- which(Best[, 5] < 5) # Use CV to check for large uncertainties
        BBfininds <- which(BB[, 5] < 5) # Use CV to check for large uncertainties
        #if(length(ylim)!=2) ylim <- range(BB[fininds, 1:3]/scal*Bmsy[2], Best[fininds, 1:3], Bp[2], unlist(obsI), Binf[,2], 0.95*Bmsy[1], 1.05*Bmsy[3])/scal
        if(length(ylim)!=2) ylim <- range(BB[BBfininds, 1:3]/scal*Bmsy[2], Best[fininds, 1:3], Bp[2], unlist(obsI), 0.95*Bmsy[1], 1.05*Bmsy[3], na.rm=TRUE)/scal
        ylim[2] <- min(c(ylim[2], 3*max(Best[fininds, 2], unlist(obsI)))) # Limit upper limit
        #if(main==-1) main <- paste('- Bmsy:',round(Bmsy[2]),' K:',round(Kest[2]))
        if(main==-1) main <- 'Absolute biomass'
        plot(inp$time, Best[,2]/scal, typ='n', xlab='Time', ylab=expression(B[t]), main=main, ylim=ylim, xlim=range(c(inp$time, tail(inp$time,1)+1)), log=log)
        axis(4, labels=pretty(ylim/Bmsy[2]), at=pretty(ylim/Bmsy[2])*Bmsy[2])
        mtext(expression(B[t]/B[MSY]), side=4, las=0, line=2.2, cex=par('cex'))
        #polygon(c(inp$time[1]-5,tail(inp$time,1)+5,tail(inp$time,1)+5,inp$time[1]-5), c(Bmsy[1],Bmsy[1],Bmsy[3],Bmsy[3]), col=cicol, border=cicol)
        #refpointci(inp$time, Bmsyvec$ll, Bmsyvec$ul, cicol)
        if(all(is.finite(unlist(Bmsyvec)))) polygon(c(inp$time, rev(inp$time)), c(Bmsyvec$ll,rev(Bmsyvec$ul)), col=cicol, border=cicol)
        cicol2 <- rgb(0, 0, 1, 0.1)
        if(!'yearsepgrowth' %in% names(inp)) polygon(c(inp$time[BBfininds], rev(inp$time[BBfininds])), c(BB[BBfininds,1], rev(BB[BBfininds,3]))/scal*Bmsy[2], col=cicol2, border=cicol2)
        abline(v=inp$time[inp$indlastobs], col='gray')
        if(plot.obs){
            for(i in 1:inp$nindex) plot.col(inp$timeI[[i]], inp$obsI[[i]]/qest[i, 2], pch=i, do.line=FALSE, cex=0.6, add=TRUE, add.legend=qlegend)
            # Highlight influential index observations
            if('infl' %in% names(rep)){
                infl <- rep$infl$infl
                indslast <- inp$nobsC # Start after catch observations
                for(i in 1:inp$nindex){
                    iinds <- indslast + 1:inp$nobsI[i]
                    infl2 <- infl[iinds, ]
                    cols <- apply(!is.na(infl2), 1, sum)
                    ncols <- length(unique(cols))
                    inds <- which(cols>0)
                    points(inp$timeI[[i]][inds], inp$obsI[[i]][inds]/qest[i, 2], pch=21, cex=0.9, bg=cols[inds])
                }
            }
        }
        if('true' %in% names(inp)){
            lines(inp$true$time, inp$true$B/scal, col='orange') # Plot true
            abline(h=inp$true$Bmsy, col='orange', lty=2)
        }
        lines(inp$time[inp$indest], Best[inp$indest,2]/scal, col='blue', lwd=1.5)
        lines(inp$time[inp$indpred], Best[inp$indpred,2]/scal, col='blue', lty=3)
        #abline(h=Bmsy[2]/scal, col='black')
        lines(inp$time, Bmsyvec$msy, col='black')
        # B CI
        if(inp$phases$logq>0){
            lines(inp$time[inp$indest], Best[inp$indest,1]/scal, col=4, lty=2, lwd=1.5)
            lines(inp$time[inp$indest], Best[inp$indest,3]/scal, col=4, lty=2, lwd=1.5)
            lines(inp$time[inp$indpred], Best[inp$indpred,1]/scal, col=4, lty=2)
            lines(inp$time[inp$indpred], Best[inp$indpred,3]/scal, col=4, lty=2)
        }
        # B/Bmsy CI
        cicol3 <- rgb(0, 0, 1, 0.2)
        if(!'yearsepgrowth' %in% names(inp)){
            lines(inp$time[inp$indest], BB[inp$indest,1]/scal*Bmsy[2], col=cicol3, lty=1, lwd=1)
            lines(inp$time[inp$indest], BB[inp$indest,3]/scal*Bmsy[2], col=cicol3, lty=1, lwd=1)
            lines(inp$time[inp$indpred], BB[inp$indpred,1]/scal*Bmsy[2], col=cicol3, lty=1, lwd=1)
            lines(inp$time[inp$indpred], BB[inp$indpred,3]/scal*Bmsy[2], col=cicol3, lty=1, lwd=1)
        }
        #if(inp$nseasons==1) lines(Binftime, Binfs/scal, col='green', lty=1)
        #tp <- inp$time[rep$inp$dtprediind]
        #points(tp, Best[rep$inp$dtprediind, 2]/scal, pch=21, bg='yellow')
        if(plot.legend){
            if(inp$nseasons==1){
                #legend('topleft', legend=c(expression('E(B'[infinity]*')'),paste(tp,'Pred.')), lty=c(1,NA), pch=c(NA,21), col=c('green',1), pt.bg=c(NA,'yellow'), bg='white')
                #legend('topleft', legend=c(expression('E(B'[infinity]*')')), lty=c(1), col=c('green'), bg='white')
            } else {
                #legend('topleft', legend=paste(tp,'Pred.'), pch=21, col=1, pt.bg='yellow', bg='white')
            }
        }
        #legend('topright', legend=c(paste(tp,'Pred.')), pch=c(21), col=c(1), pt.bg=c('yellow'), bg='white')
        if('yearsepgrowth' %in% names(inp)) abline(v=inp$yearsepgrowth, col=3)
        box(lwd=1.5)
    }
}


#' @name plotspict.bbmsy
#' @title Plot estimated B/Bmsy.
#' @details Plots estimated B/Bmsy.
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of y-axis? default: FALSE
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.bbmsy(rep)
#' @export
plotspict.bbmsy <- function(rep, logax=FALSE, main=-1, plot.legend=TRUE, ylim=NULL, plot.obs=TRUE, qlegend=TRUE){
    if(!'sderr' %in% names(rep)){
        log <- ifelse(logax, 'y', '')
        inp <- rep$inp
        # Biomass plot
        Kest <- get.par('logK', rep, exp=TRUE, fixed=TRUE)
        Bmsy <- get.par('logBmsy', rep, exp=TRUE)
        Bmsyvec <- get.msyvec(inp, Bmsy)
        #Binf <- get.par('logBinf', rep, exp=TRUE)
        qest <- get.par('logq', rep, fixed=TRUE, exp=TRUE)
        BB <- get.par('logBBmsy', rep, exp=TRUE)
        ns <- dim(BB)[1]
        #inds <- which(is.na(Binf) | Binf<0)
        cicol <- 'lightgray'
        obsI <- list()
        for(i in 1:inp$nindex) obsI[[i]] <- inp$obsI[[i]]/qest[i, 2]/Bmsy[1,2]
        #par(mar=c(5,4,4,4))
        fininds <- which(apply(BB, 1, function(x) all(is.finite(x))))
        #if(length(ylim)!=2) ylim <- range(c(BB[fininds, 1:3], unlist(obsI), 0.95*Bmsy[1]/Bmsy[2], 1.05*Bmsy[3]/Bmsy[2]), na.rm=TRUE)
        if(length(ylim)!=2) ylim <- range(c(BB[fininds, 1:3], unlist(obsI), 1), na.rm=TRUE)
        ylim[2] <- min(c(ylim[2], 3*max(BB[fininds, 2], unlist(obsI)))) # Limit upper limit
        if(main==-1) main <- 'Relative biomass'
        plot(inp$time, BB[,2], typ='n', xlab='Time', ylab=expression(B[t]/B[MSY]), ylim=ylim, xlim=range(c(inp$time, tail(inp$time,1)+1)), log=log, main=main)
        #polygon(c(inp$time[1]-5,tail(inp$time,1)+5,tail(inp$time,1)+5,inp$time[1]-5), c(Bmsy[1]/Bmsy[2],Bmsy[1]/Bmsy[2],Bmsy[3]/Bmsy[2],Bmsy[3]/Bmsy[2]), col=cicol, border=cicol)
        #polygon(c(inp$time, rev(inp$time)), c(Bmsyvec$ll/Bmsyvec$msy,rev(Bmsyvec$ul/Bmsyvec$msy)), col=cicol, border=cicol)
        cicol2 <- rgb(0, 0, 1, 0.1)
        polygon(c(inp$time[fininds], rev(inp$time[fininds])), c(BB[fininds,1], rev(BB[fininds,3])), col=cicol2, border=cicol2)
        abline(v=inp$time[inp$indlastobs], col='gray')
        if(plot.obs){
            for(i in 1:inp$nindex) plot.col(inp$timeI[[i]], obsI[[i]], pch=i, do.line=FALSE, cex=0.6, add=TRUE, add.legend=qlegend)
            # Highlight influential index observations
            if('infl' %in% names(rep)){
                infl <- rep$infl$infl
                indslast <- inp$nobsC # Start after catch observations
                for(i in 1:inp$nindex){
                    iinds <- indslast + 1:inp$nobsI[i]
                    infl2 <- infl[iinds, ]
                    cols <- apply(!is.na(infl2), 1, sum)
                    ncols <- length(unique(cols))
                    inds <- which(cols>0)
                    points(inp$timeI[[i]][inds], inp$obsI[[i]][inds]/qest[i, 2]/Bmsy[2], pch=21, cex=0.9, bg=cols[inds])
                }
            }
        }
        if('true' %in% names(inp)){
            lines(inp$true$time, inp$true$B/inp$true$Bmsy, col='orange') # Plot true
        }
        lines(inp$time[inp$indest], BB[inp$indest,2], col='blue', lwd=1.5)
        lines(inp$time[inp$indpred], BB[inp$indpred,2], col='blue', lty=3)
        cicol3 <- rgb(0, 0, 1, 0.2)
        lines(inp$time[inp$indest], BB[inp$indest,1], col=cicol3, lty=1, lwd=1)
        lines(inp$time[inp$indest], BB[inp$indest,3], col=cicol3, lty=1, lwd=1)
        lines(inp$time[inp$indpred], BB[inp$indpred,1], col=cicol3, lty=1, lwd=1)
        lines(inp$time[inp$indpred], BB[inp$indpred,3], col=cicol3, lty=1, lwd=1)
        #tp <- inp$time[rep$inp$dtprediind]
        #points(tp, BB[rep$inp$dtprediind, 2], pch=21, bg='yellow')
        abline(h=1)
        #if(plot.legend) legend('topleft',c(paste(tp,'Pred.')), pch=21, pt.bg=c('yellow'), bg='white')
        box(lwd=1.5)
    }
}


#' @name plotspict.osar
#' @title Plot one-step-ahead residuals
#' @details Plots observed versus predicted catches.
#' @param rep A result report as generated by running fit.spict.
#' @param collapse.I Collapse index residuals into one plot. Default: TRUE.
#' @param qlegend Plot legend for quarters.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' rep <- calc.osa.resid(rep)
#' plotspict.osar(rep)
#' @export
plotspict.osar <- function(rep, collapse.I=TRUE, qlegend=TRUE){
    if('osar' %in% names(rep)){
        inp <- rep$inp
        Cscal <- 1
        Cpred <- rep$osar$logCpred
        fun <- function(time, res, add=FALSE, add.legend=FALSE, col=1, pch=1, ...){
            nrem <- length(time) - length(res)
            if(nrem>0) time <- time[-nrem]
            plot.col(time, res, pch=pch, add=add, add.legend=add.legend, typ='p', ...)
            dum <- rep(NA, length(res))
            dum[is.na(res)] <- 0
            text(time, dum, labels='NA', cex=0.8, col=col)
        }
        # Catches
        pval <- round(rep$osar$logCpbias$p.value, 4)
        colmain <- ifelse(pval<0.05, 'red', 'forestgreen')
        #if('nseasons' %in% names(inp)) add.legend <- inp$nseasons > 1
        fun(rep$osar$timeC, rep$osar$logCpres, add.legend=qlegend, ylab='Catch OSAR', main=paste0('Bias p-val: ', pval), col.main=colmain)
        abline(h=0, lty=3)
        # Indices
        pval <- round(rep$osar$logIpbias[[1]]$p.value, 4)
        colmain <- ifelse(pval<0.05, 'red', 'forestgreen')
        if(collapse.I){
            ylim <- range(unlist(rep$osar$logIpres), na.rm=TRUE)
            xlim <- range(unlist(rep$osar$timeI))
        } else {
            ylim <- range(rep$osar$logIpres[[1]], na.rm=TRUE)
            xlim <- range(rep$osar$timeI[[1]])
        }
        fun(rep$osar$timeI[[1]], rep$osar$logIpres[[1]], ylab='Index OSAR', col=1, xlim=xlim, ylim=ylim, main=paste0('I1 bias p-val: ', pval), col.main=colmain)
        abline(h=0, lty=3)
        if(rep$inp$nindex>1){
            for(i in 2:rep$inp$nindex){
                ylim <- range(rep$osar$logIpres[[i]])
                xlim <- range(unlist(rep$osar$timeI[[i]]))
                if(!collapse.I){
                    pval <- round(rep$osar$logIpbias[[i]]$p.value, 4)
                    colmain <- ifelse(pval<0.05, 'red', 'forestgreen')
                    main <- paste0('I', i, ' bias p-val: ', pval)
                } else { main <- '' }
                fun(rep$osar$timeI[[i]], rep$osar$logIpres[[i]], add=collapse.I, ylab='Index OSAR', col=1, pch=i, xlim=xlim, ylim=ylim, main=main, col.main=colmain)
                if(!collapse.I){
                    abline(h=0, lty=3)
                }
            }
        }


    } else {
        stop('Could not find "osar" key in rep list! did you run calc.osa.resid?')
    }
}


#' @name plotspict.diagnostic
#' @title Plot model diagnostic (data, residuals, and more)
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' rep <- calc.osa.resid(rep)
#' plotspict.diagnostic(rep)
#' @export
plotspict.diagnostic <- function(rep){
    repflag <- FALSE
    add.legend <- FALSE
    if('obsC' %in% names(rep)){
        inp <- check.inp(rep)
        if(inp$nindex==1) mfrow <- c(2, 1)
        if(inp$nindex==2) mfrow <- c(3, 1)
        if(inp$nindex==3) mfrow <- c(2, 2)
        if(inp$nindex %in% 4:5) mfrow <- c(3, 2)
        if(inp$nindex > 5) mfrow <- c(4, 4)
    }
    if('inp' %in% names(rep)){
        repflag <- TRUE
        inp <- rep$inp
        if(inp$nindex %in% 1:2) mfrow <- c(2, 2)
        if(inp$nindex %in% 3:4) mfrow <- c(3, 2)
        if(inp$nindex %in% 5:7) mfrow <- c(3, 3)
    }
    # Determine number of plots
    if('osar' %in% names(rep)){
        mfrow <- c(4, inp$nindex+1)
    } else {
        #cat('No OSAR found in input, run calc.osa.resid to get all diagnostics.\n')
    }
    par(mfrow=mfrow)

    # Plot data
    plot.col(inp$timeC, log(inp$obsC), ylab='log catch data', main='Catch')
    for(i in 1:inp$nindex) plot.col(inp$timeI[[i]], log(inp$obsI[[i]]), ylab=paste('log index',i,'data'), main=paste('Index', i), pch=i)
   
    # OSAR plots
    if('osar' %in% names(rep)){
        plotspict.osar(rep, collapse.I=FALSE)
        resC <- rep$osar$logCpres[!is.na(rep$osar$logCpres)]
        acf(resC, main='ACF of catch OSAR', lag.max=10)
        box(lwd=1.5)
        resI <- list()
        for(i in 1:inp$nindex){
            resI[[i]] <- rep$osar$logIpres[[i]][!is.na(rep$osar$logIpres[[i]])]
            acf(resI[[i]], main=paste('ACF of index', i, 'OSAR'), lag.max=10)
            box(lwd=1.5)
        }
        pval <- round(rep$osar$logCpshapiro$p.value, 4)
        colmain <- ifelse(pval<0.05, 'red', 'forestgreen')
        qqnorm(resC, main=paste0('Catch, Shapiro p-val: ', pval), col.main=colmain)
        abline(0,1)
        box(lwd=1.5)
        for(i in 1:inp$nindex){
            pval <- round(rep$osar$logIpshapiro[[i]]$p.value, 4)
            colmain <- ifelse(pval<0.05, 'red', 'forestgreen')
            qqnorm(resI[[i]], main=paste0('I', i, ', Shapiro p-val: ', pval), col.main=colmain, pch=20+i)
            abline(0,1)
            box(lwd=1.5)
        }
    } else {
        if(repflag){
            # "Wrong" residual plots
            # Catch
            logCpred <- get.par('logCpred', rep)
            inds <- 1:inp$nobsC
            wCres <- (logCpred[inds, 2] - log(inp$obsC)) / logCpred[inds, 4]
            plot.col(inp$timeC, wCres, ylab='Smooth residuals', main='Catch')
            # Index (NOT DONE)
            #logIpred <- get.par('logIpred', rep)
            #for(i in 1:inp$nindex){
            #    inds <- 1:inp$nobsC
            #    wCres <- (logCpred[inds, 2] - log(inp$obsC)) / logCpred[inds, 4]
            #    plot.data.fun(inp$timeC, wCres, ylab='Smooth residuals', main='Catch')
            #}
        }
    }
}


#' @name plotspict.f
#' @title Plot estimated fishing mortality.
#' @details Plots estimated fishing mortality with Fmsy and associated confidence interval.
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of y-axis? default: FALSE
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.f(rep)
#' @export
plotspict.f <- function(rep, logax=FALSE, main=-1, plot.legend=TRUE, ylim=NULL){
    if(!'sderr' %in% names(rep)){
        log <- ifelse(logax, 'y', '')
        inp <- rep$inp
        cicol <- 'lightgray'
        #Fest <- get.par('logF', rep, exp=TRUE)
        Fest <- get.par('logFs', rep, exp=TRUE)
        logFest <- get.par('logFs', rep)
        FF <- get.par('logFFmsy', rep, exp=TRUE)
        logFF <- get.par('logFFmsy', rep)
        Fmsy <- get.par('logFmsy', rep, exp=TRUE)
        Fmsyd <- get.par('logFmsyd', rep, exp=TRUE)
        Fmsyvec <- get.msyvec(inp, Fmsy)
        #rest <- get.par('logr', rep, exp=TRUE, fixed=TRUE)
        #rest <- apply(rest, 2, mean)

        if(min(inp$dtc) < 1){
        #if(TRUE){
            # Annual    
            al1 <- annual(inp$time, logFest[, 1])
            al2 <- annual(inp$time, logFest[, 2])
            al3 <- annual(inp$time, logFest[, 3])
            inds <- which(!is.na(al1$annvec) & al2$anntime<=tail(inp$time[inp$indest],1))
            cl <- exp(al1$annvec[inds])
            cu <- exp(al3$annvec[inds])
            inds <- which(!is.na(al2$annvec) & al2$anntime<=tail(inp$time[inp$indest],1))
            time <- al1$anntime[inds]
            F <- exp(al2$annvec[inds])
            inds <- which(!is.na(al1$annvec) & al2$anntime>=tail(inp$time[inp$indest],1))
            clp <- exp(al1$annvec[inds])
            cup <- exp(al3$annvec[inds])
            inds <- which(!is.na(al2$annvec) & al2$anntime>=tail(inp$time[inp$indest],1))
            timep <- al1$anntime[inds]
            Fp <- exp(al2$annvec[inds])
            al1f <- annual(inp$time, logFF[, 1])
            al2f <- annual(inp$time, logFF[, 2])
            al3f <- annual(inp$time, logFF[, 3])
            inds <- which(!is.na(al1f$annvec))
            clf <- exp(al1f$annvec[inds])*Fmsy[2]
            cuf <- exp(al3f$annvec[inds])*Fmsy[2]
            inds <- which(!is.na(al2f$annvec))
            timef <- al2f$anntime[inds]
            Ff <- exp(al2f$annvec[inds])*Fmsy[2]
        } else {
            time <- inp$time[inp$indest]
            cl <- Fest[inp$indest, 1]
            F <- Fest[inp$indest, 2]
            cu <- Fest[inp$indest, 3]
            timep <- inp$time[inp$indpred]
            clp <- Fest[inp$indpred, 1]
            Fp <- Fest[inp$indpred, 2]
            cup <- Fest[inp$indpred, 3]
            timef <- inp$time
            clf <- FF[, 1]*Fmsy[2]
            Ff <- Fest[, 2] #*Fmsy[2]
            cuf <- FF[, 3]*Fmsy[2]
        }
        flag <- length(cu)==0 | all(!is.finite(cu))
        if(flag){
            fininds <- which(is.finite(Ff))
            if(length(ylim)!=2) ylim <- range(c(Ff, Fmsy[1:3], tail(Fest[, 2],1)), na.rm=TRUE)
        } else {
            fininds <- which(apply(cbind(clf, cuf), 1, function(x) all(is.finite(x))))
            if(length(ylim)!=2) ylim <- range(c(cl[fininds], cu[fininds], clf[fininds], cuf[fininds], tail(Fest[, 2],1)), na.rm=TRUE)
        }
        ylim[2] <- min(c(ylim[2], 3*max(Ff[fininds]))) # Limit upper limit
        #main <- paste('Fmsy:',round(Fmsy[2],3),' ffac:',inp$ffac)
        if(main==-1) main <- 'Absolute fishing mortality'
        plot(timef, Ff, typ='n', main=main, ylim=ylim, col='blue', ylab=expression(F[t]), xlab='Time', xlim=range(c(inp$time, tail(inp$time,1)+1)))
        axis(4, labels=pretty(ylim/Fmsy[2]), at=pretty(ylim/Fmsy[2])*Fmsy[2])
        mtext(expression(F[t]/F[MSY]), side=4, las=0, line=2.2, cex=par('cex'))
        #polygon(c(inp$time[1]-5,tail(inp$time,1)+5,tail(inp$time,1)+5,inp$time[1]-5), c(Fmsy[1],Fmsy[1],Fmsy[3],Fmsy[3]), col=cicol, border=cicol)
        polygon(c(inp$time, rev(inp$time)), c(Fmsyvec$ll,rev(Fmsyvec$ul)), col=cicol, border=cicol)
        cicol2 <- rgb(0, 0, 1, 0.1)
        if(!flag & !'yearsepgrowth' %in% names(inp)) polygon(c(timef[fininds], rev(timef[fininds])), c(clf[fininds], rev(cuf[fininds])), col=cicol2, border=cicol2)
        if(min(inp$dtc) < 1){ # Plot estimated sub annual F 
            lines(inp$time, Fest[, 2], col=rgb(0, 0, 1, 0.4))
        }
        abline(v=inp$time[inp$indlastobs], col='gray')
        if('true' %in% names(inp)){
            lines(inp$true$time, inp$true$Fs, col='orange') # Plot true
            abline(h=inp$true$Fmsy, col='orange', lty=2)
        }
        maincol <- 'blue'
        if(!flag) lines(time, cl, col=maincol, lwd=1.5, lty=2)
        lines(time, F, col=maincol, lwd=1.5)
        if(!flag) lines(time, cu, col=maincol, lwd=1.5, lty=2)
        if(!flag) lines(timep, clp, col=maincol, lty=2)
        lines(timep, Fp, col=maincol, lty=3)
        if(!flag) lines(timep, cup, col=maincol, lty=2)
        if(!flag & !'yearsepgrowth' %in% names(inp)) lines(timef, clf, col=rgb(0, 0, 1, 0.2))
        if(!flag & !'yearsepgrowth' %in% names(inp)) lines(timef, cuf, col=rgb(0, 0, 1, 0.2))
        #tp <- inp$time[inp$dtprediind]
        #points(tp, Fest[inp$dtprediind, 2], pch=21, bg='yellow')
        #abline(h=Fmsy[2], col='black')
        lines(inp$time, Fmsyvec$msy, col='black')
        #abline(h=rest[2], col='red')
        #if(plot.legend) legend('topleft',c(paste(tp,'Pred.')), pch=21, pt.bg=c('yellow'), bg='white')
        box(lwd=1.5)
    }
}

#' @name plotspict.ffmsy
#' @title Plot estimated relative fishing mortality.
#' @details Plots estimated fishing mortality with Fmsy and associated confidence interval.
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of y-axis? default: FALSE
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.ffmsy(rep)
#' @export
plotspict.ffmsy <- function(rep, logax=FALSE, main=-1, plot.legend=TRUE, ylim=NULL){
    if(!'sderr' %in% names(rep)){
        log <- ifelse(logax, 'y', '')
        inp <- rep$inp
        cicol <- 'lightgray'
        #Fest <- get.par('logF', rep, exp=TRUE)
        Fest <- get.par('logFs', rep, exp=TRUE)
        FF <- get.par('logFFmsy', rep, exp=TRUE)
        logFF <- get.par('logFFmsy', rep)
        Fmsy <- get.par('logFmsy', rep, exp=TRUE)
        Fmsyvec <- get.msyvec(inp, Fmsy)
        #rest <- get.par('logr', rep, exp=TRUE, fixed=TRUE)
        #rest <- apply(rest, 2, mean)

        if(min(inp$dtc) < 1){
        #if(TRUE){
            # Annual    
            al1 <- annual(inp$time, logFF[, 1])
            al2 <- annual(inp$time, logFF[, 2])
            al3 <- annual(inp$time, logFF[, 3])
            inds <- which(!is.na(al1$annvec) & al2$anntime<=tail(inp$time[inp$indest],1))
            cl <- exp(al1$annvec[inds])
            cu <- exp(al3$annvec[inds])
            inds <- which(!is.na(al2$annvec) & al2$anntime<=tail(inp$time[inp$indest],1))
            time <- al1$anntime[inds]
            F <- exp(al2$annvec[inds])
            inds <- which(!is.na(al1$annvec) & al2$anntime>=tail(inp$time[inp$indest],1))
            clp <- exp(al1$annvec[inds])
            cup <- exp(al3$annvec[inds])
            inds <- which(!is.na(al2$annvec) & al2$anntime>=tail(inp$time[inp$indest],1))
            timep <- al1$anntime[inds]
            Fp <- exp(al2$annvec[inds])
            al1f <- annual(inp$time, logFF[, 1])
            al2f <- annual(inp$time, logFF[, 2])
            al3f <- annual(inp$time, logFF[, 3])
            inds <- which(!is.na(al1f$annvec))
            clf <- exp(al1f$annvec[inds])
            cuf <- exp(al3f$annvec[inds])
            inds <- which(!is.na(al2f$annvec))
            timef <- al2f$anntime[inds]
            Ff <- exp(al2f$annvec[inds])
        } else {
            time <- inp$time[inp$indest]
            cl <- FF[inp$indest, 1]
            F <- FF[inp$indest, 2]
            cu <- FF[inp$indest, 3]
            timep <- inp$time[inp$indpred]
            clp <- FF[inp$indpred, 1]
            Fp <- FF[inp$indpred, 2]
            cup <- FF[inp$indpred, 3]
            timef <- inp$time
            clf <- FF[, 1]
            Ff <- FF[, 2]
            cuf <- FF[, 3]
        }
        flag <- length(cu)==0 | all(!is.finite(cu))
        if(flag){
            fininds <- which(is.finite(Ff))
            if(length(ylim)!=2) ylim <- range(c(Ff[fininds], 0.95*Fmsy[1]/Fmsy[2], 1.05*Fmsy[3]/Fmsy[2]), na.rm=TRUE)
        } else {
            fininds <- which(apply(cbind(clf, cuf), 1, function(x) all(is.finite(x))))
            if(length(ylim)!=2) ylim <- range(c(cl[fininds], cu[fininds], 0.95*Fmsy[1]/Fmsy[2], 1.05*Fmsy[3]/Fmsy[2]), na.rm=TRUE)
        }
        ylim[2] <- min(c(ylim[2], 3*max(Ff[fininds]))) # Limit upper limit
        ylim <- c(min(ylim[1], 1), max(ylim[2], 1)) # Ensure that 1 is included in ylim
        #main <- paste('Fmsy:',round(Fmsy[2],3),' ffac:',inp$ffac)
        if(main==-1) main <- 'Relative fishing mortality'
        plot(timef, Ff, typ='n', main=main, ylim=ylim, col='blue', ylab=expression(F[t]/F[MSY]), xlab='Time', xlim=range(c(inp$time, tail(inp$time,1)+1)))
        #polygon(c(inp$time[1]-5,tail(inp$time,1)+5,tail(inp$time,1)+5,inp$time[1]-5), c(Fmsy[1]/Fmsy[2],Fmsy[1]/Fmsy[2],Fmsy[3]/Fmsy[2],Fmsy[3]/Fmsy[2]), col=cicol, border=cicol)
        #polygon(c(inp$time, rev(inp$time)), c(Fmsyvec$ll/Fmsyvec$msy,rev(Fmsyvec$ul/Fmsyvec$msy)), col=cicol, border=cicol)
        cicol2 <- rgb(0, 0, 1, 0.1)
        if(!flag) polygon(c(timef[fininds], rev(timef[fininds])), c(clf[fininds], rev(cuf[fininds])), col=cicol2, border=cicol2)
        if(min(inp$dtc) < 1){ # Plot estimated sub annual F 
            lines(inp$time, FF[, 2], col=rgb(0, 0, 1, 0.4))
        }
        abline(v=inp$time[inp$indlastobs], col='gray')
        if('true' %in% names(inp)){
            lines(inp$true$time, inp$true$Fs, col='orange') # Plot true
            abline(h=inp$true$Fmsy, col='orange', lty=2)
        }
        maincol <- 'blue'
        lines(time, F, col=maincol, lwd=1.5)
        lines(timep, Fp, col=maincol, lty=3)
        if(!flag) lines(timef, clf, col=rgb(0, 0, 1, 0.2))
        if(!flag) lines(timef, cuf, col=rgb(0, 0, 1, 0.2))
        #tp <- inp$time[inp$dtprediind]
        #points(tp, Fest[inp$dtprediind, 2], pch=21, bg='yellow')
        abline(h=1, col='black')
        #abline(h=rest[2], col='red')
        #if(plot.legend) legend('topleft',c(paste(tp,'Pred.')), pch=21, pt.bg=c('yellow'), bg='white')
        box(lwd=1.5)
    }
}


#' @name plotspict.fb
#' @title Plot fishing mortality versus biomass.
#' @details Plots estimated fishing mortality as a function of biomass together with reference points and the prediction for next year given a constant F. The equilibrium biomass for F fixed to the current value is also plotted.
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of x and y-axes? default: FALSE
#' @param plot.legend Plot legend explaining triangle.
#' @param ext Add relative level axis to top and right side.
#' @param rel.axes Plot axes in relative levels instead of absolute.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.fb(rep)
#' @export
plotspict.fb <- function(rep, logax=FALSE, plot.legend=TRUE, ext=TRUE, rel.axes=FALSE, xlim=NULL, ylim=NULL){
    if(!'sderr' %in% names(rep)){
        log <- ifelse(logax, 'xy', '')
        inp <- rep$inp
        Bmsyall <- get.par('logBmsy', rep, exp=TRUE)
        Fmsyall <- get.par('logFmsy', rep, exp=TRUE)
        Bmsy <- tail(Bmsyall, 1)
        Fmsy <- tail(Fmsyall, 1)
        if(rel.axes){
            ext <- FALSE
            bscal <- Bmsy[2]
            fscal <- Fmsy[2]
            xlab <- expression(B[t]/B[MSY])
            ylab <- expression(F[t]/F[MSY])
        } else {
            bscal <- 1
            fscal <- 1
            xlab <- expression(B[t])
            ylab <- expression(F[t])
        }
        Bp <- get.par('logBp', rep, exp=TRUE)
        Best <- get.par('logB', rep, exp=TRUE)
        logBest <- get.par('logB', rep)
        qest <- get.par('logq', rep, exp=TRUE)
        Fest <- get.par('logFs', rep, exp=TRUE)
        logFest <- get.par('logFs', rep)
        ns <- dim(Best)[1]
        Fp <- Fest[ns,]
        inds <- c(max(which(names(rep$value)=='logBmsy')), max(which(names(rep$value)=='logFmsy')))
        cl <- make.ellipse(inds, rep)
        if(min(inp$dtc) < 1){
            alb <- annual(inp$time, logBest[, 2])
            alf <- annual(inp$time, logFest[, 2])
            aind <- which(inp$time[inp$dtprediind] == alb$anntime)
            bbb <- exp(alb$annvec)/bscal
            fff <- exp(alf$annvec)/fscal
            fbtime <- alb$anntime
        } else {
            bbb <- Best[inp$indest,2]/bscal
            fff <- Fest[inp$indest,2]/fscal
            pind <- rep$inp$dtprediind
            fbtime <- inp$time[inp$indest]
        }
        Fl <- tail(unname(fff), 1)
        Bl <- tail(unname(bbb), 1)
        EBinf <- get.EBinf(rep)/bscal # Should be used instead of the above.
        # Limits
        if(length(xlim)!=2){
            xlim <- range(c(exp(cl[,1]), Best[,2], EBinf)/bscal, na.rm=TRUE)
            if(min(inp$dtc) < 1){
                # New annual limits
                xlim <- range(c(exp(alb$annvec), exp(cl[, 1]), EBinf)/bscal, na.rm=TRUE)
            }
            xlim[2] <- min(c(xlim[2], 8*Bmsy[2]/bscal))
        }
        if(length(ylim)!=2){
            ylim <- range(c(exp(cl[,2]), Fest[,2])/fscal, na.rm=TRUE)
            if(min(inp$dtc) < 1){
                # New annual limits
                ylim <- range(c(exp(alf$annvec)/fscal, exp(cl[, 2])/fscal), na.rm=TRUE)
            }
            ylim[2] <- min(c(ylim[2], 8*Fmsy[2]/fscal))
        }
        # Plotting
        #par(mar=c(5,4,4,4))
        plot(Bmsy[2]/bscal, Fmsy[2]/fscal, typ='n', xlim=xlim, xlab=xlab, ylab=ylab, ylim=ylim, log=log)
        abline(v=0, col='red', lty=2)
        if(ext){
            axis(3, labels=pretty(xlim/Bmsy[2]), at=pretty(xlim/Bmsy[2])*Bmsy[2])
            mtext(expression(B[t]/B[MSY]), side=3, las=0, line=2, cex=par('cex'))
            axis(4, labels=pretty(ylim/Fmsy[2]), at=pretty(ylim/Fmsy[2])*Fmsy[2])
            mtext(expression(F[t]/F[MSY]), side=4, las=0, line=2.5, cex=par('cex'))
        }
        alpha <- 0.15
        polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xlim[2]*2, xlim[2]*2), c(Fmsy[2], -10, -10, Fmsy[2])/fscal, col=rgb(0,0.8,0,alpha), border=NA) # Green
        polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xlim[1]-xlim[2], xlim[1]-xlim[2]), c(Fmsy[2], -10, -10, Fmsy[2])/fscal, col=rgb(1,1,0,alpha), border=NA) # Yellow
        polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xlim[2]*2, xlim[2]*2), c(Fmsy[2], ylim[2]*2, ylim[2]*2, Fmsy[2])/fscal, col=rgb(1,1,0,alpha), border=NA) # Yellow
        polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xlim[1]-xlim[2], xlim[1]-xlim[2]), c(Fmsy[2], ylim[2]*2, ylim[2]*2, Fmsy[2])/fscal, col=rgb(0.6,0,0,alpha), border=NA) # Red
        cicol <- 'lightgray'
        cicolrgb <- col2rgb(cicol)/255
        cicoluse <- rgb(cicolrgb[1], cicolrgb[2], cicolrgb[3], 0.7)
        cicol2 <- 'gray'
        cicol2rgb <- col2rgb(cicol2)/255
        cicol2use <- rgb(cicol2rgb[1], cicol2rgb[2], cicol2rgb[3], 0.7)
        polygon(exp(cl[,1])/bscal, exp(cl[,2])/fscal, col=cicoluse, border=cicol2use)
        #arrow.line(Best[,2]/bscal, Fest[,2], length=0.05, col='blue')
        if('true' %in% names(inp)){
            #lines(inp$true$B/bscal, inp$true$F, col='orange') # Plot true
            points(inp$true$Bmsy/bscal, inp$true$Fmsy/fscal, pch=24, bg='orange')
        }
        maincol <- rgb(0,0,1,0.8)
        if(min(inp$dtc) < 1){
            lines(bbb, fff, col=maincol, lwd=1.5)
        } else {
            lines(bbb, fff, col=maincol, lwd=1.5)
            lines(Best[inp$indpred,2]/bscal, Fest[inp$indpred,2]/fscal, col=maincol, lty=3)
        }
        lines(c(Bl, EBinf), c(Fl, Fl), lwd=1.5, lty=3, col='blue')
        points(EBinf, Fl, pch=24, bg='yellow')
        points(Bmsy[2]/bscal, Fmsy[2]/fscal, pch=3)
        nr <- length(inp$ini$logr)
        if(nr > 1){
            points(Bmsyall[1:(nr-1), 2]/bscal, Fmsyall[1:(nr-1), 2]/fscal, pch=24, bg='magenta')
            if(plot.legend) legend('topright', c('Current MSY', 'Previous MSY'), pch=3, col=c('black', 'magenta'), bg='white')
        } else {
            if(plot.legend) legend('topright', expression('E(B'[infinity]*')'), pch=24, pt.bg='yellow', bg='white')
            #if(plot.legend) legend('topright', c('Estimated MSY'), pch=3, col=c('black'), bg='white')
        }
        points(Bl, Fl, pch=22, bg='magenta')
        text(Bl, Fl, tail(fbtime, 1), pos=4, cex=0.65, offset=0.25)
        points(bbb[1], fff[1], pch=21, bg='white')
        text(bbb[1], fff[1], fbtime[1], pos=4, cex=0.65, offset=0.25)
        box(lwd=1.5)
    }
}


#' @name plotspict.catch
#' @title Plot observed catch and predictions.
#' @details Plots observed catch and predictions using the current F and Fmsy. The plot also contains the equilibrium catch if the current F is maintained.
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.catch(rep)
#' @export
plotspict.catch <- function(rep, main=-1, plot.legend=TRUE, ylim=NULL){
    if(!'sderr' %in% names(rep)){
        inp <- rep$inp
        Cscal <- 1
        cicol <- 'lightgray'
        MSY <- get.par('logMSY', rep, exp=TRUE)
        MSYvec <- get.msyvec(inp, MSY)
        #Crc <- get.par('logCrcsum', rep, exp=TRUE)
        #Cpredsub <- get.par('Cpredsub', rep)
        #Cpsub <- get.par('logCpsub', rep, exp=TRUE) # could be deleted
        Cpredest <- get.par('logCpred', rep, exp=TRUE)
        Cpredest[Cpredest<0] <- 0
        rep$Cp[rep$Cp<0] <- 0
        indest <- which(inp$timeCpred <= tail(inp$timeC,1))
        indpred <- which(inp$timeCpred >= tail(inp$timeC,1))
        dtc <- inp$dtcp
        if(min(inp$dtc) < 1){
        #if(FALSE){
            alo <- annual(inp$timeC, inp$obsC/inp$dtc)
            timeo <- alo$anntime
            obs <- alo$annvec
            al1 <- annual(inp$timeCpred[indest], Cpredest[indest, 1]/dtc[indest])
            al2 <- annual(inp$timeCpred[indest], Cpredest[indest, 2]/dtc[indest])
            al3 <- annual(inp$timeCpred[indest], Cpredest[indest, 3]/dtc[indest])
            inds <- which(!is.na(al2$annvec))
            time <- al2$anntime[inds]
            c <- al2$annvec[inds]
            cl <- al1$annvec[inds]
            cu <- al3$annvec[inds]
            al1p <- annual(inp$timeCpred[indpred], Cpredest[indpred, 1]/dtc[indpred])
            al2p <- annual(inp$timeCpred[indpred], Cpredest[indpred, 2]/dtc[indpred])
            al3p <- annual(inp$timeCpred[indpred], Cpredest[indpred, 3]/dtc[indpred])
            inds <- which(!is.na(al2p$annvec))
            timep <- al2p$anntime[inds]
            cp <- al2p$annvec[inds]
            clp <- al1p$annvec[inds]
            cup <- al3p$annvec[inds]
            al1f <- annual(inp$timeCpred, Cpredest[, 1]/dtc)
            al2f <- annual(inp$timeCpred, Cpredest[, 2]/dtc)
            al3f <- annual(inp$timeCpred, Cpredest[, 3]/dtc)
            inds <- which(!is.na(al2f$annvec))
            timef <- al2f$anntime[inds]
            clf <- al1f$annvec[inds]
            cf <- al2f$annvec[inds]
            cuf <- al3f$annvec[inds]
            if(any(inp$dtc==1)){
                inds <- which(inp$dtc==1)
                timeo <- c(timeo, inp$timeC[inds])
                obs <- c(obs, inp$obsC[inds])
                #time <- c(time, inp$timeCpred[inds])
                #c <- c(c, Cpredest[inds, 2])
                #cl <- c(cl, Cpredest[inds, 1])
                #cu <- c(cu, Cpredest[inds, 3])
                timeunsort <- c(time, inp$timeCpred[inds])
                timesort <- sort(timeunsort, index=TRUE)
                time <- timesort$x
                #obs <- c(obs, inp$obsC[inds])[timesort$ix]
                c <- c(c, Cpredest[inds, 2])[timesort$ix]
                cl <- c(cl, Cpredest[inds, 1])[timesort$ix]
                cu <- c(cu, Cpredest[inds, 3])[timesort$ix]
            }
        } else {
            timeo <- inp$timeC
            obs <- inp$obsC/inp$dtc
            time <- inp$timeCpred[indest]
            c <- Cpredest[indest, 2]/dtc[indest]
            cl <- Cpredest[indest, 1]
            cu <- Cpredest[indest, 3]
            timep <- inp$timeCpred[indpred]
            cp <- Cpredest[indpred, 2]/dtc[indpred]
            clp <- Cpredest[indpred, 1]
            cup <- Cpredest[indpred, 3]
            timef <- inp$timeCpred
            clf <- Cpredest[, 1]
            cf <- Cpredest[, 2]/dtc
            cuf <- Cpredest[, 3]
        }
        fininds <- which(apply(cbind(clf, cuf), 1, function(x) all(is.finite(x))))
        if(length(ylim)!=2){
            ylim <- range(c(cl, cu, 0.9*MSY[1], 1.07*MSY[3]), na.rm=TRUE)/Cscal
            if(inp$dtpredc > 0) ylim <- range(ylim, clf[fininds], cuf[fininds])
        }
        ylim[2] <- min(c(ylim[2], 3*max(cf[fininds]))) # Limit upper limit
        if(main==-1) main <- 'Catch'
        plot(time, c, typ='n', main=main, xlab='Time', ylab=paste('Catch'), xlim=range(c(inp$time, tail(inp$time,1))), ylim=ylim)
        #polygon(c(inp$time[1]-5,tail(inp$time,1)+5,tail(inp$time,1)+5,inp$time[1]-5), c(MSY[1],MSY[1],MSY[3],MSY[3])/Cscal, col=cicol, border=cicol)
        polygon(c(inp$time, rev(inp$time)), c(MSYvec$ll,rev(MSYvec$ul)), col=cicol, border=cicol)
        cicol2 <- rgb(0, 0, 1, 0.1)
        #polygon(c(timef, rev(timef)), c(clf, rev(cuf)), col=cicol2, border=cicol2)
        #lines(timef, clf, col=rgb(0, 0, 1, 0.2))
        #lines(timef, cuf, col=rgb(0, 0, 1, 0.2))
        lines(time, cl, col=4, lwd=1.5, lty=2)
        lines(time, cu, col=4, lwd=1.5, lty=2)
        abline(v=tail(inp$timeC,1), col='gray')
        #points(timeo, obs/Cscal, cex=0.7)
        plot.col(timeo, obs/Cscal, cex=0.7, do.line=FALSE, add=TRUE)
        #plot.col(inp$timeC, inp$obsC/Cscal, cex=0.7, do.line=FALSE, add=TRUE)
        # Highlight influential index observations
        if('infl' %in% names(rep) & min(inp$dtc) == 1){
            infl <- rep$infl$infl[1:inp$nobsC, ]
            cols <- apply(!is.na(infl), 1, sum)
            ncols <- length(unique(cols))
            inds <- which(cols>0)
            points(inp$timeC[inds], inp$obsC[inds]/Cscal, pch=21, cex=0.9, bg=cols[inds])
        }
        if('true' %in% names(inp)) abline(h=inp$true$MSY, col='orange', lty=2)
        #abline(h=MSY[2]/Cscal)
        lines(inp$time, MSYvec$msy)
        lines(time, c, col=4, lwd=1.5)
        if(inp$dtpredc > 0){
            lines(timep, cp, col=4, lty=3)
            lines(timep, clp, col=4, lwd=1, lty=2)
            lines(timep, cup, col=4, lwd=1, lty=2)
            #points(inp$timepredc, Crc[2], pch=21, bg='yellow')
        }
        #if(min(inp$dtc) == 1 & plot.legend) legend('topleft',c(paste(tail(inp$timeCpred,1),'Pred.')), pch=21, pt.bg=c('yellow'), bg='white')
        #if(min(inp$dtc) == 1 & inp$dtpredc > 0 & plot.legend & Crc[2] > ylim[1] & Crc[2] < ylim[2]) legend('topright', 'C at Fmsy', pch=21, pt.bg=c('yellow'), bg='white')
        box(lwd=1.5)
    }
}


#' @name plotspict.production
#' @title Plot theoretical production curve and estimates.
#' @details Plots the theoretical production curve (production as a function of biomass) as calculated from the estimated model parameters. Overlaid is the estimated production/biomass trajectory.
#' @param rep A result report as generated by running fit.spict.
#' @param n.plotyears Plot years next to points if number of points is below n.plotyears. Default: 40.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.production(rep)
#' @export
plotspict.production <- function(rep, n.plotyears=40){
    if(!'sderr' %in% names(rep)){
        inp <- rep$inp
        Kest <- get.par('logK', rep, exp=TRUE)
        mest <- get.par('logm', rep, exp=TRUE)
        nr <- dim(mest)[1]
        gamma <- get.par('gamma', rep)
        n <- get.par('logn', rep, exp=TRUE)
        Bmsy <- get.par('logBmsy', rep, exp=TRUE)
        Bmsy <- c(1,1)
        nBplot <- 200
        Bplot <- seq(0.5*1e-8, Kest[2], length=nBplot)
        pfun <- function(gamma, m, K, n, B) gamma*m/K*B*(1 - (B/K)^(n-1))
        Pst <- list()
        for(i in 1:nr) Pst[[i]] <- pfun(gamma[2], mest[i,2], Kest[2], n[2], Bplot)
        ylim <- range(unlist(Pst)/Bmsy[2], na.rm=TRUE)
        #if(inp$reportall & inp$nseasons==1){
        if(inp$reportall){
            Best <- get.par('logB', rep, exp=TRUE)
            Pest <- get.par('P', rep)
            Bplot <- seq(0.5*min(c(1e-8, Best[, 2])), 1*max(c(Kest[2], Best[, 2])), length=nBplot)
            for(i in 1:nr) Pst[[i]] <- pfun(gamma[2], mest[i,2], Kest[2], n[2], Bplot)
            Bvec <- Best[inp$ic[1:dim(Pest)[1]], 2]
            ylim <- range(Pest[,2]/Bmsy[2], unlist(Pst)/Bmsy[2], na.rm=TRUE)
        }
        xlim <- range(Bplot/Kest[2], na.rm=TRUE)
        dt <- inp$dt[-1]
        inde <- inp$indest[-length(inp$indest)]
        indp <- inp$indpred[-1]-1
        plot(Bplot/Kest[2], Pst[[nr]]/Bmsy[2], typ='l', ylim=ylim, xlim=xlim, xlab='B/K', ylab='Production', col=1, main='Production curve')
        if(nr > 1) for(i in 1:(nr-1)) lines(Bplot/Kest[2], Pst[[i]]/Bmsy[2], col='gray')
        #if(inp$reportall & inp$nseasons==1){
        if(inp$reportall){
            lines(Bvec/Kest[2], Pest[, 2]/Bmsy[2], col=4, lwd=1.5)
            points(Bvec/Kest[2], Pest[, 2]/Bmsy[2], col=4, pch=20, cex=0.7)
            par(xpd=TRUE)
            if(length(inp$ic) < n.plotyears) text(Bvec/Kest[2], Pest[, 2]/Bmsy[2], labels=inp$time[inp$ic], cex=0.65, pos=4, offset=0.25)
            par(xpd=FALSE)
        }
        mx <- (1/n[2])^(1/(n[2]-1))
        abline(v=mx, lty=3)
        abline(h=0, lty=3)
        box(lwd=1.5)
    }
}


#' @name plotspict.prodrate
#' @title Plot production rate as a function of biomass.
#' @details OBSOLETE!
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.prodrate(rep)
plotspict.prodrate <- function(rep){
    if(!'sderr' %in% names(rep)){
        inp <- rep$inp
        Best <- get.par('logB', rep, exp=TRUE)
        Kest <- get.par('logK', rep, exp=TRUE)
        rest <- get.par('logr', rep, exp=TRUE)
        nest <- get.par('logn', rep, exp=TRUE)
        Pest <- get.par('P', rep)
        inds <- unique(c(inp$ic, unlist(inp$ii)))
        B <- Best[-inp$ns,2]
        r <- rest[2]
        p <- nest[2]-1
        K <- Kest[2]
        pr <- r*(1-(B[inds]/K)^p)
        probs <- Pest[inds, 2]/inp$dt[inds]/B[inds]
        plot(B[inds], probs, typ='p', xlab='B', ylab='Production/B', col='blue', main=bquote(pseudoR^2 == .(round(rep$stats$pseudoRsq, 4))))
        lines(B[inds], pr)
        abline(h=0, lty=3)
        legend('topright', legend=c('Observed production/B', expression(r*(1-(B/K)^p))), col=c(4,1), pch=c(1,NA), lty=c(NA,1))
        box(lwd=1.5)
    }
}


#' @name plotspict.tc
#' @title Plot time constant.
#' @details Plots the time required for the biomass to reach a certain proportion of Bmsy. The time required to reach 95\% of Bmsy is highlighted.
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.tc(rep)
#' @export
plotspict.tc <- function(rep){
    if(!'sderr' %in% names(rep)){
        inp <- rep$inp
        B0cur <- get.par('logBl', rep, exp=TRUE)[2]
        Kest <- get.par('logK', rep, exp=TRUE)
        m <- get.par('logm', rep, exp=TRUE)
        #mmean <- apply(m, 2, mean)[2]
        mmean <- tail(m, 1)[2]
        n <- get.par('logn', rep, exp=TRUE)
        gamma <- calc.gamma(n[2])
        sdbest <- get.par('logsdb', rep, exp=TRUE)
        Fmsy <- tail(get.par('logFmsy', rep, exp=TRUE), 1)
        Bmsy <- tail(get.par('logBmsy', rep, exp=TRUE), 1)
        if(B0cur < Bmsy[2]) do.flag <- ifelse(B0cur/Bmsy[2]>0.95, FALSE, TRUE)
        if(B0cur > Bmsy[2]) do.flag <- ifelse(Bmsy[2]/B0cur>0.95, FALSE, TRUE)
        if(do.flag){
            if(B0cur < Bmsy[2]) facvec <- c(0, 0.75, 0.95, 1)
            if(B0cur > Bmsy[2]) facvec <- c(2, 1.25, 1.05, 1)
            Fvec <- round(facvec*Fmsy[2], digits=4)
            nFvec <- length(Fvec)
            g <- function(F, K, m, n, sdb, B0, dt){
                return(exp( log(B0) + (gamma*m/K - gamma*m/K*(B0/K)^(n-1) - F - 0.5*sdb^2)*dt ))
            }
            simdt <- 0.01
            nt <- 10000
            Bsim <- matrix(0, nFvec, nt)
            time <- matrix(0, nFvec, nt)
            for(i in 1:nFvec){
                time[i, ] <- seq(0, simdt*(nt-1), by=simdt)
                Bsim[i, ] <- rep(0, nt)
                Bsim[i, 1] <- B0cur
                for(j in 2:nt){
                    Bsim[i, j] <- g(Fvec[i], Kest[2], mmean, n[2], sdbest[2], Bsim[i, j-1], simdt)
                }
            }
            Bsim <- Bsim/Bmsy[2]
            frac <- 0.95
            if(B0cur < Bmsy[2]) inds <- which(Bsim[nFvec, ]<0.99)
            if(B0cur > Bmsy[2]) inds <- which(Bsim[nFvec, ]>(1/0.99))
            ylim <- range(Bsim[nFvec, ], na.rm=TRUE)
            xlim <- range(time[nFvec, inds])
            xlim[2] <- min(xlim[2], 15) # Max 15 years ahead
            plot(time[1, ], Bsim[1, ], typ='l', xlim=xlim, ylim=ylim, col=3, ylab='Proportion of Bmsy', xlab='Years to Bmsy', main='Time to Bmsy', lwd=1.5)
            abline(h=c(frac, 1/frac), lty=1, col='lightgray')
            abline(h=1, lty=3)
            for(i in 2:nFvec) lines(time[i, ], Bsim[i, ], col=i+2, lwd=1.5)
            vt <- rep(0, nFvec)
            if(B0cur < Bmsy[2]) for(i in 1:nFvec) vt[i] <- time[i, max(which(Bsim[i, ]<frac))]
            if(B0cur > Bmsy[2]) for(i in 1:nFvec) vt[i] <- time[i, max(which(1/Bsim[i, ]<frac))]
            for(i in 1:nFvec) abline(v=vt[i], col=i+2, lty=2)
            lgnplace <- 'bottomright'
            if(B0cur > Bmsy[2]) lgnplace <- 'topright'
            legend(lgnplace, legend=paste('F =',facvec,'x Fmsy'), lty=1, col=2+(1:nFvec), lwd=rep(1.5,nFvec), bg='white')
            points(vt, rep(par('usr')[3], nFvec), col=3:(nFvec+2), pch=4)
        }
        box(lwd=1.5)
    }
}


#' @name plotspict.season
#' @title Plot the mean F cycle
#' @details If seasonal data are available the seasonal cycle in the fishing mortality can be estimated. This function plots this mean F cycle.
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @export
plotspict.season <- function(rep){
    if(!'sderr' %in% names(rep)){
        jan <- as.POSIXct("2015-01-01 00:00:01 UTC", tz='UTC')
        apr <- jan+(31+28+31)*24*60*60
        jul <- apr+(30+31+30)*24*60*60
        oct <- jul+(31+31+30)*24*60*60
        logF <- get.par('logF', rep)
        meanlogF <- mean(logF[, 2])
        logphi <- get.par('logphi', rep)
        inds <- which(colnames(rep$cov.fixed) == 'logphi')
        covmat <- rep$cov.fixed[inds, inds]
        require(MASS)
        nunc <- 200
        set.seed(1234)
        a <- mvrnorm(nunc, mu=logphi[, 2], Sigma=covmat)
        seasonsplineest <- get.spline(logphi[, 2], order=rep$inp$splineorder, dtfine=rep$inp$dteuler)
        #seasonsplineest <- c(seasonsplineest, seasonsplineest[1])
        test <- seq(0, 1, length=length(seasonsplineest))
        yest <- exp(meanlogF + seasonsplineest)
        seasonsplinesmoo <- get.spline(logphi[, 2], order=rep$inp$splineorder)
        nsss <- length(seasonsplinesmoo)
        t <- seq(0, 1, length=nsss)
        y <- exp(meanlogF + seasonsplinesmoo)
        #seasonsplinesmoo <- c(seasonsplinesmoo, seasonsplinesmoo[1])
        yunc <- matrix(0, nunc, nsss)
        for(i in 1:nunc) yunc[i, ] <- exp(get.spline(a[i, ], order=rep$inp$splineorder) + meanlogF)
        #yunc <- exp(meanlogF + seasonsplinesmoo)        
        ylim <- range(yest, y, yunc)
        if("true" %in% names(rep$inp)){
            seasonsplinetrue <- get.spline(rep$inp$true$logphi, order=rep$inp$true$splineorder, dtfine=rep$inp$true$dteuler)
            seasonsplinetrue <- c(seasonsplinetrue, seasonsplinetrue[1])
            ttrue <- seq(0, 1, length=length(seasonsplinetrue))
            ytrue <- exp(mean(log(rep$inp$true$F)) + seasonsplinetrue)
            ylim <- range(c(yest, y, ytrue))
        }
        plot(t, y, typ='n', xaxt='n', xlab='Time of year', ylab='Mean F cycle', main=paste('Spline order:',rep$inp$splineorder), ylim=ylim)
        unccol <- rgb(0.5, 0.5, 0.5, 0.1)
        matplot(t, t(yunc), typ='l', col=unccol, lty=1, add=TRUE)
        lab <- strftime(c(jan, apr, jul, oct, jan), format='%b')
        ats <- c(0, 0.25, 0.5, 0.75, 1)
        abline(v=ats, lty=3, col='lightgray')
        abline(h=pretty(yunc), lty=3, col='lightgray')
        lines(t, y, lwd=1, col='green')
        lines(test, yest, lwd=1.5, col=4, typ='s')
        if("true" %in% names(rep$inp)){
            lines(ttrue, ytrue, lwd=1, col='orange', typ='s')            
        }
        axis(1, at=ats, labels=lab)
        box(lwd=1.5)
    }
}


#' @name plotspict.btrend
#' @title Plot the expected biomass trend
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @export
plotspict.btrend <- function(rep){
    if(!'sderr' %in% names(rep)){
        Bind <- get.par('Bind', rep)
        B <- get.par('logB', rep, exp=TRUE)
        plot(rep$inp$time, Bind[, 2], typ='l', ylim=c(-2, 2), xlab='Time', ylab='B trend')
        lines(rep$inp$time, Bind[, 1], lty=2)
        lines(rep$inp$time, Bind[, 3], lty=2)
        lines(rep$inp$time[-1], diff(B[, 2]), col=4, lwd=1.5)
        abline(h=0, col='gray')
        legend('topleft', legend=c('Expected', 'Observed'), lty=1, lwd=c(1, 1.5), col=c(1, 4))
        box(lwd=1.5)
    }
}


#' @name plot.spictcls
#' @title 3x3 plot illustrating spict results.
#' @details Create a 3x3 plot containing the following:
#' \itemize{
#'  \item{1. Biomass using plotspict.biomass().}
#'  \item{2. One-step-ahead residuals, only if calculated, using plotspict.osar().}
#'  \item{3. One-step-ahead auto-correlation function (only if calculated).}
#'  \item{4. Estimated F versus estimated B using plotspict.fb().}
#'  \item{5. Estimated fishing mortality using plotspict.f().}
#'  \item{6. Observed versus predicted catches using plotspict.catch().}
#'  \item{7. Observed versus theoretical production using plotspict.production().}
#'  \item{8. Calculated time-constant using plotspict.tc().}
#' }
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of relevant axes? default: FALSE
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plot(rep)
#' @export
plot.spictcls <- function(rep, logax=FALSE){
    if('inp' %in% names(rep)){
        inp <- rep$inp
        if(inp$reportall){
            #dev.new(width=10, height=10)
            if('osar' %in% names(rep)){
                par(mfrow=c(4, 3), oma=c(0.2, 0.2, 0, 0), mar=c(5,4,2,3.5))
            } else {
                par(mfrow=c(3, 3), oma=c(0.2, 0.2, 0, 0), mar=c(5,4,2,3.5))
            }
            # Biomass
            plotspict.biomass(rep, logax=logax)
            # F
            plotspict.f(rep, logax=logax)
            # Catch
            plotspict.catch(rep)
            # B/Bmsy
            plotspict.bbmsy(rep, logax=logax, qlegend=FALSE)
            # F/Fmsy
            plotspict.ffmsy(rep, logax=logax)
            # F versus B
            plotspict.fb(rep, logax=logax, plot.legend=TRUE)
        } else {
            if('osar' %in% names(rep)){
                par(mfrow=c(3, 2), oma=c(0.2, 0.2, 0, 0), mar=c(5,4,2,3.5))
            } else {
                par(mfrow=c(2, 1), oma=c(0.2, 0.2, 0, 0), mar=c(5,4,2,3.5))
            }
        }
        # Production curve
        plotspict.production(rep)
        # Seasonal F
        if(inp$nseasons > 1) plotspict.season(rep)
        # Time constant
        if(inp$nseasons == 1) plotspict.tc(rep)
        # Priors
        if('priors' %in% names(rep$inp)) plotspict.priors(rep, do.plot=1)
        if('osar' %in% names(rep)){
            # One-step-ahead catch residuals
            plotspict.osar(rep, qlegend=FALSE)
            #acf(rep$osar$logCpres[!is.na(rep$osar$logCpres)], main='')
            #mtext('ACF of catch OSAR', cex=0.8, font=2)
            #box(lwd=1.5)
            #acf(rep$osar$logIpres[[1]][!is.na(rep$osar$logIpres[[1]])], main='')
            #mtext('ACF of index 1 OSAR', cex=0.8, font=2)
            #box(lwd=1.5)
        }
        if(inp$reportall){
            if('infl' %in% names(rep)){
                # Plot influence summary
                plotspict.inflsum(rep)
            }
            # Plot expected biomass trend
            #plotspict.btrend(rep)
        }
    } else {
        if('obsC' %in% names(rep)){
            inp <- check.inp(rep)
            plotspict.diagnostic(inp)
        } else {
            stop('Nothing to plot!')
        }
    }
}


#' @name put.ax
#' @title Adds the x-axis to influence plots
#' @details TBA
#' @param rep A valid result from calc.influence().
#' @return Nothing.
put.xax <- function(rep){
    inp <- rep$inp
    sernames <- colnames(rep$infl$dosarpvals)
    xs <- c(inp$nobsC, inp$nobsI)
    xat <- cumsum(xs[-length(xs)]+0.5)
    xmid <- c(0, xat) + xs/2
    axis(1, at=xat, labels='')
    axis(1, at=xmid, labels=sernames, tick=FALSE)
    abline(v=xat, lty=2, col='gray')
}


#' @name plotspict.infl
#' @title Plots influence statistics of observations.
#' @details TBA
#' @param rep A valid result from calc.influence().
#' @return Nothing.
#' @export
plotspict.infl <- function(rep){
    inp <- rep$inp
    #sernames <- c('C', paste0('I', 1:inp$nindex))
    dfbeta <- rep$infl$dfbeta
    dpar <- rep$infl$dpar
    ddetcov <- rep$infl$ddetcov
    dosarpvals <- rep$infl$dosarpvals
    sernames <- colnames(dosarpvals)
    nser <- inp$nindex+1
    nobs <- inp$nobsC + sum(inp$nobsI)
    parnams <- colnames(dfbeta)
    np <- length(parnams)
    rwnms <- rownames(dfbeta)
    infl <- rep$infl$infl
    par(mfrow=c(2,2))
    # Plot covratio
    dl <- 3*length(rep$par.fixed)/nobs
    covratio <- exp(ddetcov)
    ac <- abs(covratio-1)
    inds <- which(ac > dl)
    plot(ac, ylab='abs(covratio-1)', ylim=c(0, 1.05*max(ac)), xlab='', xaxt='n', main='COVRATIO')
    abline(h=dl)
    text(inds, ac[inds], rwnms[inds], pos=3, cex=0.7)
    put.xax(rep)
    box(lwd=1.5)
    # Plot OSAR p-values
    osarpvals <- get.osar.pvals(rep)
    alpha <- 0.05
    orgres <- osarpvals < alpha
    newres <- dosarpvals < alpha
    chgmat <- matrix(0, nobs, nser)
    for(i in 1:nser) chgmat[, i] <- newres[, i]-orgres[i]
    inds <- which(chgmat!=0)
    rc <- arrayInd(inds, dim(dosarpvals))
    nms <- rwnms[rc[, 1]]
    plot(dosarpvals[, 1], ylab='p-value', ylim=0:1, xlab='', xaxt='n', main='OSAR p-values')
    for(i in 2:nser) points(dosarpvals[, i], col=i)
    abline(h=osarpvals, col=1:nser)
    for(i in 1:length(inds)){
        text(rc[i, 1], dosarpvals[rc[i, 1], rc[i, 2]], nms[i], pos=3, cex=0.7, col=rc[i, 2])
    }
    abline(h=0.05, lwd=2, lty=3)
    legend('topleft', legend=sernames, pch=1, col=1:nser)
    put.xax(rep)
    box(lwd=1.5)
    # Plot dfbeta
    adfbeta <- abs(dfbeta)
    al <- 2/sqrt(nobs)
    inds <- which(adfbeta>al)
    rc <- arrayInd(inds, dim(adfbeta))
    nms <- rwnms[rc[, 1]]
    plot(adfbeta[, 1], ylim=c(0, 1.05*max(adfbeta)), ylab='abs dfbeta', xlab='', xaxt='n', main='DFBETA')
    for(i in 2:np) points(adfbeta[, i], col=i)
    abline(h=al, lwd=2, lty=3)
    for(i in 1:length(inds)){
        text(rc[i, 1], adfbeta[rc[i, 1], rc[i, 2]], nms[i], pos=3, cex=0.7, col=rc[i, 2])
        text(rc[i, 1], adfbeta[rc[i, 1], rc[i, 2]], round(dpar[rc[i, 1], rc[i, 2]], 3), pos=1, cex=0.7, col=rc[i, 2])
    }
    legend('topleft', legend=parnams, pch=1, col=1:np)
    put.xax(rep)
    box(lwd=1.5)
    # Plot of influence
    plotspict.inflsum(rep)
    box(lwd=1.5)
}


#' @name plotspict.inflsum
#' @title Plots summary of influence statistics of observations.
#' @details TBA
#' @param rep A valid result from calc.influence().
#' @return Nothing.
#' @export
plotspict.inflsum <- function(rep){
    infl <- rep$infl$infl
    nobs <- dim(infl)[1]
    ninfl <- dim(infl)[2]
    matplot(infl, pch=1, col=1, yaxt='n', ylab='', xlab='', xaxt='n', main='Overall influence', type='n')
    axis(2, at=1:ninfl, labels=colnames(infl))
    cols <- apply(!is.na(infl), 1, sum)
    for(i in 1:nobs) abline(v=i, col=cols[i], lwd=(1+cols[i]/5))
    matplot(infl, pch=1, col=1, add=TRUE)
    put.xax(rep)
}


#' @name plotspict.likprof
#' @title Plots result of likelihood profiling.
#' @details TBA
#' @param input Result of running likprof.spict().
#' @param logpar If TRUE log of parameters are shown.
#' @return Nothing but shows a plot.
#' @export
plotspict.likprof <- function(input, logpar=FALSE){
    repflag <- 'par.fixed' %in% names(input)
    if(repflag){
        rep <- input
        inp <- rep$inp
        nll <- rep$opt$objective
    } else {
        inp <- input
        nll <- min(inp$likprof$likvals)
    }
    likprof <- inp$likprof
    np <- length(likprof$pars)
    pv <- likprof$parvals
    pars <- likprof$pars
    loginds <- grep('log', pars)
    expinds <- setdiff(1:np, loginds)
    if(!logpar){
        pv[, loginds] <- exp(pv[, loginds])
        pars[loginds] <- gsub('log', '', pars[loginds])
    } else {
        pv[, expinds] <- log(pv[, expinds])
        pars[expinds] <- paste0('log', pars[expinds])
    }
    if(np==1){
        plot(pv[, 1], likprof$likvals, typ='l', xlab=pars[1], ylab='negative log lik')
        lrlim <- 0.5*qchisq(0.95, 1) + nll
        abline(h=lrlim, lty=2)
    } else {
        pvals <- pchisq(2*(likprof$likvals - nll), np)
        contour(pv[, 1], pv[, 2], pvals, xlab=pars[1], ylab=pars[2], levels=c(0.5, 0.8, 0.95))
    }
    box(lwd=1.5)
}


#' @name plotspict.retro
#' @title Plot results of retrospective analysis 
#' @param rep A valid result from fit.spict.
#' @return Nothing
#' @export
plotspict.retro <- function(rep){
    par(mfrow=c(2, 2), oma=c(1, 0.2, 0, 2), mar=c(4,4,2,1))
    nretroyear <- length(rep$retro)
    bs <- list()
    for(i in 1:nretroyear) bs[[i]] <- get.par('logB', rep$retro[[i]], exp=TRUE)[rep$retro[[i]]$inp$indest, 2]
    bbs <- list()
    for(i in 1:nretroyear) bbs[[i]] <- get.par('logBBmsy', rep$retro[[i]], exp=TRUE)[rep$retro[[i]]$inp$indest, 2]
    fs <- list()
    for(i in 1:nretroyear) fs[[i]] <- get.par('logF', rep$retro[[i]], exp=TRUE)[rep$retro[[i]]$inp$indest, 2]
    ffs <- list()
    for(i in 1:nretroyear) ffs[[i]] <- get.par('logFFmsy', rep$retro[[i]], exp=TRUE)[rep$retro[[i]]$inp$indest, 2]
    time <- list()
    for(i in 1:nretroyear) time[[i]] <- rep$retro[[i]]$inp$time[rep$retro[[i]]$inp$indest]

    # Do plots
    par(mfrow=c(2, 2))
    plot(time[[1]], bs[[1]], typ='l', ylim=range(unlist(bs)), xlab='Time', ylab = expression(B[t]), lwd=1.5)
    for(i in 2:nretroyear) lines(time[[i]], bs[[i]], col=i, lwd=1.5)
    box(lwd=1.5)
    plot(time[[1]], fs[[1]], typ='l', ylim=range(unlist(fs)), xlab='Time', ylab = expression(F[t]), lwd=1.5)
    for(i in 2:nretroyear) lines(time[[i]], fs[[i]], col=i, lwd=1.5)
    box(lwd=1.5)
    plot(time[[1]], bbs[[1]], typ='l', ylim=range(unlist(bbs)), xlab='Time', ylab = expression(B[t]/B[MSY]), lwd=1.5)
    for(i in 2:nretroyear) lines(time[[i]], bbs[[i]], col=i, lwd=1.5)
    box(lwd=1.5)
    plot(time[[1]], ffs[[1]], typ='l', ylim=range(unlist(ffs)), xlab='Time', ylab = expression(F[t]/F[MSY]), lwd=1.5)
    for(i in 2:nretroyear) lines(time[[i]], ffs[[i]], col=i, lwd=1.5)
    box(lwd=1.5)
    #par(xpd=TRUE)
    #x <- max(unlist(time))+0.1*diff(range(unlist(time)))
    #for(i in 1:nretroyear){
    #    y <- max(unlist(ffs))-0.1*(i-1)*diff(range(unlist(ffs)))
    #    points(x, y, pch=22, col=i, bg=i)
    #    text(x, y, max(time[[i]]), pos=4)
    #}
}


#' @name plotspict.ci
#' @title Plot catch and index data.
#' @param inp An input list containing data.
#' @return Nothing
#' @export
plotspict.ci <- function(inp){
    inp <- check.inp(inp)
    y <- inp$obsC
    z <- inp$obsI[[1]]
    c <- guess.m(inp, all=TRUE)
    if(class(c) == 'list'){ 
        MSY <- c$MSY
        Emsy <- c$Emsy
        a <- c$a
        b <- c$b
        x <- c$x
        mod0 <- c$mod0
        xlim <- Re(polyroot(c(0, a, b)))
        xp <- data.frame('x'=seq(xlim[1], xlim[2], length=100))
        yp <- a*xp$x + b*xp$x^2 # Dome
        yp0 <- predict(mod0, xp)
        if(inp$nseasons > 1){
            par(mfrow=c(4, 2))
        } else {
            par(mfrow=c(3, 2))
        }
    } else {
        MSY <- c
        if(inp$nseasons > 1){
            par(mfrow=c(2, 2))
        } else {
            par(mfrow=c(1, 2))
        }
    }
    plot.seasondiff <- function(time, obs, ylab='Obs'){
        dt <- time[-length(time)]
        dy <- diff(log(obs))
        plot(dt, dy, typ='n', col='lightgray', ylab=ylab, xlab='Time')
        plot.col(dt, dy, do.line=FALSE, add=TRUE, typ='l')
        abline(h=0, lty=2, col='gray')
        box(lwd=1.5)
    }
    plot(inp$timeC, y, typ='l', ylab='Catch', xlab='Time', main=paste('MSY guess:', round(MSY, 2)))
    add.legend <- inp$nseasons > 1
    plot.col(inp$timeC, y, do.line=FALSE, cex=0.6, add=TRUE, add.legend=add.legend)
    abline(h=MSY, lty=2)
    grid()
    box(lwd=1.5)
    for(i in 1:inp$nindex){
        plot(inp$timeI[[1]], inp$obsI[[i]], typ='l', ylab=paste('Index', i), xlab='Time')
        plot.col(inp$timeI[[i]], inp$obsI[[i]], pch=i, do.line=FALSE, cex=0.6, add=TRUE)
    }
    grid()
    box(lwd=1.5)
    if(inp$nseasons > 1){
        plot.seasondiff(inp$timeC, y, ylab='diff log catch')
        plot.seasondiff(inp$timeI[[1]], inp$obsI[[1]], ylab='diff log index 1')
    }
    if(class(c) == 'list'){    
        plot(x, z, typ='b', xlim=xlim, ylab='Index', xlab='Catch/Index (E, effort proxy)', main=paste('R-squared:', round(summary(mod0)$r.squared, 3)), ylim=range(0, a, z))
        lines(xp$x, yp0, col=4)
        box(lwd=1.5)
        plot(x, y, typ='b', xlim=xlim, ylim=range(0, y), ylab='Catch', xlab='Catch/Index (E, effort proxy)', main=paste('Emsy guess:', round(Emsy, 3)))
        abline(h=MSY, lty=2)
        lines(xp$x, yp, col=4)
        box(lwd=1.5)
        plot(z, y, typ='b', ylab='Catch', xlab='Index')
        abline(h=MSY, lty=2)
        box(lwd=1.5)
        plot(y[-length(y)], diff(z)/z[-length(z)], typ='b', xlab='Catch', ylab='Proportional increase in index')
        abline(h=0, lty=2)
        abline(v=MSY, lty=2)
        box(lwd=1.5)
    }
}


#' @name plotspict.priors
#' @title Plot priors and posterior distribution.
#' @param rep A result from fit.spict.
#' @param do.plot Integer defining maximum number of priors to plot.
#' @return Nothing
#' @export
plotspict.priors <- function(rep, do.plot=4){
    inp <- rep$inp
    npriors <- length(inp$priors)
    useflags <- numeric(npriors)
    for(i in 1:npriors) useflags[i] <- inp$priors[[i]][3]
    inds <- which(useflags==1)
    ninds <- length(inds)
    ninds <- min(ninds, do.plot)
    nused <- sum(useflags)
    if(ninds > 0){
        for(i in 1:ninds){
            j <- inds[i]
            priorvec <- inp$priors[[j]]
            nm <- names(inp$priors)[j]
            nmpl <- sub('log', '', nm)
            par <- get.par(nm, rep, exp=FALSE)
            if(nm == 'logB'){
                par <- par[priorvec[5], ]
                nmpl <- paste0(nmpl, round(priorvec[4]))
            }
            xmin <- par[2] - 3*par[4]
            xmax <- par[2] + 3*par[4]
            x <- seq(xmin, xmax, length=200)
            priorvals <- dnorm(x, priorvec[1], priorvec[2])
            posteriorvals <- dnorm(x, par[2], par[4])
            plot(exp(x), priorvals, typ='l', xlab=nmpl, ylab='Density', log='x', lwd=1.5, ylim=c(0, max(priorvals, posteriorvals)*1.3))
            lines(exp(x), posteriorvals, col=3, lwd=1.5)
            legend('topright', legend=c('Prior', 'Post.'), lty=1, col=c(1, 3), lwd=1.5)
            box(lwd=1.5)
        }
    }
}

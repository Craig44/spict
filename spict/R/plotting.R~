#' @name plotspict.biomass
#' @title Plot estimated biomass.
#' @details Plots estimated biomass, Bmsy with confidence limits.
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of y-axis? default: FALSE
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.biomass(rep)
#' @export
plotspict.biomass <- function(rep, logax=FALSE, main=-1, plot.legend=TRUE, ylim=NULL, plot.obs=TRUE){
    if(!'sderr' %in% names(rep)){
        log <- ifelse(logax, 'y', '')
        inp <- rep$inp
        # Biomass plot
        Best <- get.par('logB', rep, exp=TRUE, random=TRUE)
        ns <- dim(Best)[1]
        Kest <- get.par('logK', rep, exp=TRUE, fixed=TRUE)
        Bmsy <- get.par('logBmsy', rep, exp=TRUE)
        Bmsyvec <- get.msyvec(inp, Bmsy)
        #Binf <- get.par('logBinf', rep, exp=TRUE)
        qest <- get.par('logq', rep, exp=TRUE)
        BB <- get.par('logBBmsy', rep, exp=TRUE)
        #inds <- which(is.na(Binf) | Binf<0)
        #Binf[inds] <- 1e-12
        #annlist <- annual(inp$time, Binf[, 2])
        #Binftime <- annlist$anntime
        #Binfs <- annlist$annvec
        Bp <- get.par('logBp', rep, exp=TRUE)
        scal <- 1
        cicol <- 'lightgray'
        #cicol <- 'ivory2'
        obsI <- list()
        for(i in 1:inp$nindex) obsI[[i]] <- inp$obsI[[i]]/qest[i, 2]
        #par(mar=c(5,4,4,4))
        #fininds <- which(apply(Best, 1, function(x) all(abs(x) < 1e8)))
        fininds <- which(Best[, 5] < 5) # Use CV to check for large uncertainties
        #if(length(ylim)!=2) ylim <- range(BB[fininds, 1:3]/scal*Bmsy[2], Best[fininds, 1:3], Bp[2], unlist(obsI), Binf[,2], 0.95*Bmsy[1], 1.05*Bmsy[3])/scal
        if(length(ylim)!=2) ylim <- range(BB[fininds, 1:3]/scal*Bmsy[2], Best[fininds, 1:3], Bp[2], unlist(obsI), 0.95*Bmsy[1], 1.05*Bmsy[3], na.rm=TRUE)/scal
        ylim[2] <- min(c(ylim[2], 3*max(Best[fininds, 2], unlist(obsI)))) # Limit upper limit
        #if(main==-1) main <- paste('- Bmsy:',round(Bmsy[2]),' K:',round(Kest[2]))
        if(main==-1) main <- 'Absolute biomass'
        plot(inp$time, Best[,2]/scal, typ='n', xlab='Time', ylab=expression(B[t]), main=main, ylim=ylim, xlim=range(c(inp$time, tail(inp$time,1)+1)), log=log)
        axis(4, labels=pretty(ylim/Bmsy[2]), at=pretty(ylim/Bmsy[2])*Bmsy[2])
        mtext(expression(B[t]/B[MSY]), side=4, las=0, line=2.2, cex=par('cex'))
        #polygon(c(inp$time[1]-5,tail(inp$time,1)+5,tail(inp$time,1)+5,inp$time[1]-5), c(Bmsy[1],Bmsy[1],Bmsy[3],Bmsy[3]), col=cicol, border=cicol)
        #refpointci(inp$time, Bmsyvec$ll, Bmsyvec$ul, cicol)
        polygon(c(inp$time, rev(inp$time)), c(Bmsyvec$ll,rev(Bmsyvec$ul)), col=cicol, border=cicol)
        cicol2 <- rgb(0, 0, 1, 0.1)
        if(!'yearsepgrowth' %in% names(inp)) polygon(c(inp$time[fininds], rev(inp$time[fininds])), c(BB[fininds,1], rev(BB[fininds,3]))/scal*Bmsy[2], col=cicol2, border=cicol2)
        abline(v=inp$time[inp$indlastobs], col='gray')
        if(plot.obs){
            for(i in 1:inp$nindex) plot.col(inp$timeI[[i]], inp$obsI[[i]]/qest[i, 2], pch=i, do.line=FALSE, cex=0.6, add=TRUE)
            # Highlight influential index observations
            if('infl' %in% names(rep)){
                infl <- rep$infl$infl
                indslast <- inp$nobsC # Start after catch observations
                for(i in 1:inp$nindex){
                    iinds <- indslast + 1:inp$nobsI[i]
                    infl2 <- infl[iinds, ]
                    cols <- apply(!is.na(infl2), 1, sum)
                    ncols <- length(unique(cols))
                    inds <- which(cols>0)
                    points(inp$timeI[[i]][inds], inp$obsI[[i]][inds]/qest[i, 2], pch=21, cex=0.9, bg=cols[inds])
                }
            }
        }
        if('true' %in% names(inp)){
            lines(inp$true$time, inp$true$B/scal, col='orange') # Plot true
            abline(h=inp$true$Bmsy, col='orange', lty=2)
        }
        lines(inp$time[inp$indest], Best[inp$indest,2]/scal, col='blue', lwd=1.5)
        lines(inp$time[inp$indpred], Best[inp$indpred,2]/scal, col='blue', lty=3)
        #abline(h=Bmsy[2]/scal, col='black')
        lines(inp$time, Bmsyvec$msy, col='black')
        # B CI
        if(inp$phases$logq>0){
            lines(inp$time[inp$indest], Best[inp$indest,1]/scal, col=4, lty=2, lwd=1.5)
            lines(inp$time[inp$indest], Best[inp$indest,3]/scal, col=4, lty=2, lwd=1.5)
            lines(inp$time[inp$indpred], Best[inp$indpred,1]/scal, col=4, lty=2)
            lines(inp$time[inp$indpred], Best[inp$indpred,3]/scal, col=4, lty=2)
        }
        # B/Bmsy CI
        cicol3 <- rgb(0, 0, 1, 0.2)
        if(!'yearsepgrowth' %in% names(inp)){
            lines(inp$time[inp$indest], BB[inp$indest,1]/scal*Bmsy[2], col=cicol3, lty=1, lwd=1)
            lines(inp$time[inp$indest], BB[inp$indest,3]/scal*Bmsy[2], col=cicol3, lty=1, lwd=1)
            lines(inp$time[inp$indpred], BB[inp$indpred,1]/scal*Bmsy[2], col=cicol3, lty=1, lwd=1)
            lines(inp$time[inp$indpred], BB[inp$indpred,3]/scal*Bmsy[2], col=cicol3, lty=1, lwd=1)
        }
        #if(inp$nseasons==1) lines(Binftime, Binfs/scal, col='green', lty=1)
        #tp <- inp$time[rep$inp$dtprediind]
        #points(tp, Best[rep$inp$dtprediind, 2]/scal, pch=21, bg='yellow')
        if(plot.legend){
            if(inp$nseasons==1){
                #legend('topleft', legend=c(expression('E(B'[infinity]*')'),paste(tp,'Pred.')), lty=c(1,NA), pch=c(NA,21), col=c('green',1), pt.bg=c(NA,'yellow'), bg='white')
                #legend('topleft', legend=c(expression('E(B'[infinity]*')')), lty=c(1), col=c('green'), bg='white')
            } else {
                #legend('topleft', legend=paste(tp,'Pred.'), pch=21, col=1, pt.bg='yellow', bg='white')
            }
        }
        #legend('topright', legend=c(paste(tp,'Pred.')), pch=c(21), col=c(1), pt.bg=c('yellow'), bg='white')
        if('yearsepgrowth' %in% names(inp)) abline(v=inp$yearsepgrowth, col=3)
        box(lwd=1.5)
    }
}


#' @name plotspict.bbmsy
#' @title Plot estimated B/Bmsy.
#' @details Plots estimated B/Bmsy.
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of y-axis? default: FALSE
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.bbmsy(rep)
#' @export
plotspict.bbmsy <- function(rep, logax=FALSE, main=-1, plot.legend=TRUE, ylim=NULL, plot.obs=TRUE){
    if(!'sderr' %in% names(rep)){
        log <- ifelse(logax, 'y', '')
        inp <- rep$inp
        # Biomass plot
        Kest <- get.par('logK', rep, exp=TRUE, fixed=TRUE)
        Bmsy <- get.par('logBmsy', rep, exp=TRUE)
        Bmsyvec <- get.msyvec(inp, Bmsy)
        #Binf <- get.par('logBinf', rep, exp=TRUE)
        qest <- get.par('logq', rep, fixed=TRUE, exp=TRUE)
        BB <- get.par('logBBmsy', rep, exp=TRUE)
        ns <- dim(BB)[1]
        #inds <- which(is.na(Binf) | Binf<0)
        cicol <- 'lightgray'
        obsI <- list()
        for(i in 1:inp$nindex) obsI[[i]] <- inp$obsI[[i]]/qest[i, 2]/Bmsy[1,2]
        #par(mar=c(5,4,4,4))
        fininds <- which(apply(BB, 1, function(x) all(is.finite(x))))
        if(length(ylim)!=2) ylim <- range(c(BB[fininds, 1:3], unlist(obsI), 0.95*Bmsy[1]/Bmsy[2], 1.05*Bmsy[3]/Bmsy[2]), na.rm=TRUE)
        ylim[2] <- min(c(ylim[2], 3*max(BB[fininds, 2], unlist(obsI)))) # Limit upper limit
        if(main==-1) main <- 'Relative biomass'
        plot(inp$time, BB[,2], typ='n', xlab='Time', ylab=expression(B[t]/B[MSY]), ylim=ylim, xlim=range(c(inp$time, tail(inp$time,1)+1)), log=log, main=main)
        #polygon(c(inp$time[1]-5,tail(inp$time,1)+5,tail(inp$time,1)+5,inp$time[1]-5), c(Bmsy[1]/Bmsy[2],Bmsy[1]/Bmsy[2],Bmsy[3]/Bmsy[2],Bmsy[3]/Bmsy[2]), col=cicol, border=cicol)
        #polygon(c(inp$time, rev(inp$time)), c(Bmsyvec$ll/Bmsyvec$msy,rev(Bmsyvec$ul/Bmsyvec$msy)), col=cicol, border=cicol)
        cicol2 <- rgb(0, 0, 1, 0.1)
        polygon(c(inp$time[fininds], rev(inp$time[fininds])), c(BB[fininds,1], rev(BB[fininds,3])), col=cicol2, border=cicol2)
        abline(v=inp$time[inp$indlastobs], col='gray')
        if(plot.obs){
            for(i in 1:inp$nindex) plot.col(inp$timeI[[i]], obsI[[i]], pch=i, do.line=FALSE, cex=0.6, add=TRUE)
            # Highlight influential index observations
            if('infl' %in% names(rep)){
                infl <- rep$infl$infl
                indslast <- inp$nobsC # Start after catch observations
                for(i in 1:inp$nindex){
                    iinds <- indslast + 1:inp$nobsI[i]
                    infl2 <- infl[iinds, ]
                    cols <- apply(!is.na(infl2), 1, sum)
                    ncols <- length(unique(cols))
                    inds <- which(cols>0)
                    points(inp$timeI[[i]][inds], inp$obsI[[i]][inds]/qest[i, 2]/Bmsy[2], pch=21, cex=0.9, bg=cols[inds])
                }
            }
        }
        if('true' %in% names(inp)){
            lines(inp$true$time, inp$true$B/inp$true$Bmsy, col='orange') # Plot true
        }
        lines(inp$time[inp$indest], BB[inp$indest,2], col='blue', lwd=1.5)
        lines(inp$time[inp$indpred], BB[inp$indpred,2], col='blue', lty=3)
        cicol3 <- rgb(0, 0, 1, 0.2)
        lines(inp$time[inp$indest], BB[inp$indest,1], col=cicol3, lty=1, lwd=1)
        lines(inp$time[inp$indest], BB[inp$indest,3], col=cicol3, lty=1, lwd=1)
        lines(inp$time[inp$indpred], BB[inp$indpred,1], col=cicol3, lty=1, lwd=1)
        lines(inp$time[inp$indpred], BB[inp$indpred,3], col=cicol3, lty=1, lwd=1)
        #tp <- inp$time[rep$inp$dtprediind]
        #points(tp, BB[rep$inp$dtprediind, 2], pch=21, bg='yellow')
        abline(h=1)
        #if(plot.legend) legend('topleft',c(paste(tp,'Pred.')), pch=21, pt.bg=c('yellow'), bg='white')
        box(lwd=1.5)
    }
}


#' @name plotspict.osar
#' @title Plot one-step-ahead residuals
#' @details Plots observed versus predicted catches.
#' @param rep A result report as generated by running fit.spict.
#' @param collapse.I Collapse index residuals into one plot. Default: TRUE.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' rep <- calc.osa.resid(rep)
#' plotspict.osar(rep)
#' @export
plotspict.osar <- function(rep, collapse.I=TRUE){
    if('osar' %in% names(rep)){
        inp <- rep$inp
        Cscal <- 1
        Cpred <- rep$osar$logCpred
        fun <- function(time, res, add=FALSE, col=1, pch=1, ...){
            nrem <- length(time) - length(res)
            if(nrem>0) time <- time[-nrem]
            plot.col(time, res, pch=pch, add=add, typ='p', ...)
            dum <- rep(NA, length(res))
            dum[is.na(res)] <- 0
            text(time, dum, labels='NA', cex=0.8, col=col)
        }
        # Catches
        pval <- round(rep$osar$logCpbias$p.value, 4)
        colmain <- ifelse(pval<0.05, 'red', 'forestgreen')
        fun(rep$inp$timeC, rep$osar$logCpres, ylab='Catch OSAR', main=paste0('Bias p-val: ', pval), col.main=colmain)
        abline(h=0, lty=3)
        # Indices
        pval <- round(rep$osar$logIpbias[[1]]$p.value, 4)
        colmain <- ifelse(pval<0.05, 'red', 'forestgreen')
        if(collapse.I){
            ylim <- range(unlist(rep$osar$logIpres), na.rm=TRUE)
            xlim <- range(unlist(rep$inp$timeI))
        } else {
            ylim <- range(rep$osar$logIpres[[1]], na.rm=TRUE)
            xlim <- range(rep$inp$timeI[[1]])
        }
        fun(rep$inp$timeI[[1]], rep$osar$logIpres[[1]], ylab='Index OSAR', col=1, xlim=xlim, ylim=ylim, main=paste0('I1 bias p-val: ', pval), col.main=colmain)
        abline(h=0, lty=3)
        if(rep$inp$nindex>1){
            for(i in 2:rep$inp$nindex){
                ylim <- range(rep$osar$logIpres[[i]])
                xlim <- range(unlist(rep$inp$timeI[[i]]))
                if(!collapse.I){
                    pval <- round(rep$osar$logIpbias[[i]]$p.value, 4)
                    colmain <- ifelse(pval<0.05, 'red', 'forestgreen')
                    main <- paste0('I', i, ' bias p-val: ', pval)
                } else { main <- '' }
                fun(rep$inp$timeI[[i]], rep$osar$logIpres[[i]], add=collapse.I, ylab='Index OSAR', col=1, pch=i, xlim=xlim, ylim=ylim, main=main, col.main=colmain)
                if(!collapse.I){
                    abline(h=0, lty=3)
                }
            }
        }


    } else {
        stop('Could not find "osar" key in rep list! did you run calc.osa.resid?')
    }
}


#' @name plotspict.diagnostic
#' @title Plot model diagnostic (data, residuals, and more)
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' rep <- calc.osa.resid(rep)
#' plotspict.diagnostic(rep)
#' @export
plotspict.diagnostic <- function(rep){
    repflag <- FALSE
    if('obsC' %in% names(rep)){
        inp <- check.inp(rep)
        if(inp$nindex==1) mfrow <- c(2, 1)
        if(inp$nindex==2) mfrow <- c(3, 1)
        if(inp$nindex==3) mfrow <- c(2, 2)
        if(inp$nindex %in% 4:5) mfrow <- c(3, 2)
        if(inp$nindex > 5) mfrow <- c(4, 4)
    }
    if('inp' %in% names(rep)){
        repflag <- TRUE
        inp <- rep$inp
        if(inp$nindex %in% 1:2) mfrow <- c(2, 2)
        if(inp$nindex %in% 3:4) mfrow <- c(3, 2)
        if(inp$nindex %in% 5:7) mfrow <- c(3, 3)
    }
    # Determine number of plots
    if('osar' %in% names(rep)){
        mfrow <- c(4, inp$nindex+1)
    } else {
        #cat('No OSAR found in input, run calc.osa.resid to get all diagnostics.\n')
    }
    par(mfrow=mfrow)

    # Plot data
    plot.col(inp$timeC, log(inp$obsC), ylab='log catch data', main='Catch')
    for(i in 1:inp$nindex) plot.col(inp$timeI[[i]], log(inp$obsI[[i]]), ylab=paste('log index',i,'data'), main=paste('Index', i), pch=i)

   
    # OSAR plots
    if('osar' %in% names(rep)){
        plotspict.osar(rep, collapse.I=FALSE)
        resC <- rep$osar$logCpres[!is.na(rep$osar$logCpres)]
        acf(resC, main='ACF of catch OSAR')
        box(lwd=1.5)
        resI <- list()
        for(i in 1:inp$nindex){
            resI[[i]] <- rep$osar$logIpres[[i]][!is.na(rep$osar$logIpres[[i]])]
            acf(resI[[i]], main=paste('ACF of index', i, 'OSAR'))
            box(lwd=1.5)
        }
        pval <- round(rep$osar$logCpshapiro$p.value, 4)
        colmain <- ifelse(pval<0.05, 'red', 'forestgreen')
        qqnorm(resC, main=paste0('Catch, Shapiro p-val: ', pval), col.main=colmain)
        abline(0,1)
        box(lwd=1.5)
        for(i in 1:inp$nindex){
            pval <- round(rep$osar$logIpshapiro[[i]]$p.value, 4)
            colmain <- ifelse(pval<0.05, 'red', 'forestgreen')
            qqnorm(resI[[i]], main=paste0('I', i, ', Shapiro p-val: ', pval), col.main=colmain, pch=20+i)
            abline(0,1)
            box(lwd=1.5)
        }
    } else {
        if(repflag){
            # "Wrong" residual plots
            # Catch
            logCpred <- get.par('logCpred', rep)
            inds <- 1:inp$nobsC
            wCres <- (logCpred[inds, 2] - log(inp$obsC)) / logCpred[inds, 4]
            plot.col(inp$timeC, wCres, ylab='Smooth residuals', main='Catch')
            # Index (NOT DONE)
            #logIpred <- get.par('logIpred', rep)
            #for(i in 1:inp$nindex){
            #    inds <- 1:inp$nobsC
            #    wCres <- (logCpred[inds, 2] - log(inp$obsC)) / logCpred[inds, 4]
            #    plot.data.fun(inp$timeC, wCres, ylab='Smooth residuals', main='Catch')
            #}
        }
    }
}


#' @name plotspict.f
#' @title Plot estimated fishing mortality.
#' @details Plots estimated fishing mortality with Fmsy and associated confidence interval.
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of y-axis? default: FALSE
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.f(rep)
#' @export
plotspict.f <- function(rep, logax=FALSE, main=-1, plot.legend=TRUE, ylim=NULL){
    if(!'sderr' %in% names(rep)){
        log <- ifelse(logax, 'y', '')
        inp <- rep$inp
        cicol <- 'lightgray'
        #Fest <- get.par('logF', rep, exp=TRUE)
        Fest <- get.par('logFs', rep, exp=TRUE)
        logFest <- get.par('logFs', rep)
        FF <- get.par('logFFmsy', rep, exp=TRUE)
        logFF <- get.par('logFFmsy', rep)
        Fmsy <- get.par('logFmsy', rep, exp=TRUE)
        Fmsyvec <- get.msyvec(inp, Fmsy)
        #rest <- get.par('logr', rep, exp=TRUE, fixed=TRUE)
        #rest <- apply(rest, 2, mean)

        if(min(inp$dtc) < 1){
        #if(TRUE){
            # Annual    
            al1 <- annual(inp$time, logFest[, 1])
            al2 <- annual(inp$time, logFest[, 2])
            al3 <- annual(inp$time, logFest[, 3])
            inds <- which(!is.na(al1$annvec) & al2$anntime<=tail(inp$time[inp$indest],1))
            cl <- exp(al1$annvec[inds])
            cu <- exp(al3$annvec[inds])
            inds <- which(!is.na(al2$annvec) & al2$anntime<=tail(inp$time[inp$indest],1))
            time <- al1$anntime[inds]
            F <- exp(al2$annvec[inds])
            inds <- which(!is.na(al1$annvec) & al2$anntime>=tail(inp$time[inp$indest],1))
            clp <- exp(al1$annvec[inds])
            cup <- exp(al3$annvec[inds])
            inds <- which(!is.na(al2$annvec) & al2$anntime>=tail(inp$time[inp$indest],1))
            timep <- al1$anntime[inds]
            Fp <- exp(al2$annvec[inds])
            al1f <- annual(inp$time, logFF[, 1])
            al2f <- annual(inp$time, logFF[, 2])
            al3f <- annual(inp$time, logFF[, 3])
            inds <- which(!is.na(al1f$annvec))
            clf <- exp(al1f$annvec[inds])*Fmsy[2]
            cuf <- exp(al3f$annvec[inds])*Fmsy[2]
            inds <- which(!is.na(al2f$annvec))
            timef <- al2f$anntime[inds]
            Ff <- exp(al2f$annvec[inds])*Fmsy[2]
        } else {
            time <- inp$time[inp$indest]
            cl <- Fest[inp$indest, 1]
            F <- Fest[inp$indest, 2]
            cu <- Fest[inp$indest, 3]
            timep <- inp$time[inp$indpred]
            clp <- Fest[inp$indpred, 1]
            Fp <- Fest[inp$indpred, 2]
            cup <- Fest[inp$indpred, 3]
            timef <- inp$time
            clf <- FF[, 1]*Fmsy[2]
            Ff <- Fest[, 2] #*Fmsy[2]
            cuf <- FF[, 3]*Fmsy[2]
        }
        flag <- length(cu)==0
        if(flag){
            fininds <- which(is.finite(Ff))
            if(length(ylim)!=2) ylim <- range(c(Ff, Fmsy[1:3], tail(Fest[, 2],1)), na.rm=TRUE)
        } else {
            fininds <- which(apply(cbind(clf, cuf), 1, function(x) all(is.finite(x))))
            if(length(ylim)!=2) ylim <- range(c(cl[fininds], cu[fininds], clf[fininds], cuf[fininds], tail(Fest[, 2],1)), na.rm=TRUE)
        }
        ylim[2] <- min(c(ylim[2], 3*max(Ff[fininds]))) # Limit upper limit
        #main <- paste('Fmsy:',round(Fmsy[2],3),' ffac:',inp$ffac)
        if(main==-1) main <- 'Absolute fishing mortality'
        plot(timef, Ff, typ='n', main=main, ylim=ylim, col='blue', ylab=expression(F[t]), xlab='Time', xlim=range(c(inp$time, tail(inp$time,1)+1)))
        axis(4, labels=pretty(ylim/Fmsy[2]), at=pretty(ylim/Fmsy[2])*Fmsy[2])
        mtext(expression(F[t]/F[MSY]), side=4, las=0, line=2.2, cex=par('cex'))
        #polygon(c(inp$time[1]-5,tail(inp$time,1)+5,tail(inp$time,1)+5,inp$time[1]-5), c(Fmsy[1],Fmsy[1],Fmsy[3],Fmsy[3]), col=cicol, border=cicol)
        polygon(c(inp$time, rev(inp$time)), c(Fmsyvec$ll,rev(Fmsyvec$ul)), col=cicol, border=cicol)
        cicol2 <- rgb(0, 0, 1, 0.1)
        if(!flag & !'yearsepgrowth' %in% names(inp)) polygon(c(timef[fininds], rev(timef[fininds])), c(clf[fininds], rev(cuf[fininds])), col=cicol2, border=cicol2)
        if(min(inp$dtc) < 1){ # Plot estimated sub annual F 
            lines(inp$time, Fest[, 2], col=rgb(0, 0, 1, 0.4))
        }
        abline(v=inp$time[inp$indlastobs], col='gray')
        if('true' %in% names(inp)){
            lines(inp$true$time, inp$true$Fs, col='orange') # Plot true
            abline(h=inp$true$Fmsy, col='orange', lty=2)
        }
        maincol <- 'blue'
        if(!flag) lines(time, cl, col=maincol, lwd=1.5, lty=2)
        lines(time, F, col=maincol, lwd=1.5)
        if(!flag) lines(time, cu, col=maincol, lwd=1.5, lty=2)
        if(!flag) lines(timep, clp, col=maincol, lty=2)
        lines(timep, Fp, col=maincol, lty=3)
        if(!flag) lines(timep, cup, col=maincol, lty=2)
        if(!flag & !'yearsepgrowth' %in% names(inp)) lines(timef, clf, col=rgb(0, 0, 1, 0.2))
        if(!flag & !'yearsepgrowth' %in% names(inp)) lines(timef, cuf, col=rgb(0, 0, 1, 0.2))
        #tp <- inp$time[inp$dtprediind]
        #points(tp, Fest[inp$dtprediind, 2], pch=21, bg='yellow')
        #abline(h=Fmsy[2], col='black')
        lines(inp$time, Fmsyvec$msy, col='black')
        #abline(h=rest[2], col='red')
        #if(plot.legend) legend('topleft',c(paste(tp,'Pred.')), pch=21, pt.bg=c('yellow'), bg='white')
        box(lwd=1.5)
    }
}

#' @name plotspict.ffmsy
#' @title Plot estimated relative fishing mortality.
#' @details Plots estimated fishing mortality with Fmsy and associated confidence interval.
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of y-axis? default: FALSE
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.ffmsy(rep)
#' @export
plotspict.ffmsy <- function(rep, logax=FALSE, main=-1, plot.legend=TRUE, ylim=NULL){
    if(!'sderr' %in% names(rep)){
        log <- ifelse(logax, 'y', '')
        inp <- rep$inp
        cicol <- 'lightgray'
        #Fest <- get.par('logF', rep, exp=TRUE)
        Fest <- get.par('logFs', rep, exp=TRUE)
        FF <- get.par('logFFmsy', rep, exp=TRUE)
        logFF <- get.par('logFFmsy', rep)
        Fmsy <- get.par('logFmsy', rep, exp=TRUE)
        Fmsyvec <- get.msyvec(inp, Fmsy)
        #rest <- get.par('logr', rep, exp=TRUE, fixed=TRUE)
        #rest <- apply(rest, 2, mean)

        if(min(inp$dtc) < 1){
        #if(TRUE){
            # Annual    
            al1 <- annual(inp$time, logFF[, 1])
            al2 <- annual(inp$time, logFF[, 2])
            al3 <- annual(inp$time, logFF[, 3])
            inds <- which(!is.na(al1$annvec) & al2$anntime<=tail(inp$time[inp$indest],1))
            cl <- exp(al1$annvec[inds])
            cu <- exp(al3$annvec[inds])
            inds <- which(!is.na(al2$annvec) & al2$anntime<=tail(inp$time[inp$indest],1))
            time <- al1$anntime[inds]
            F <- exp(al2$annvec[inds])
            inds <- which(!is.na(al1$annvec) & al2$anntime>=tail(inp$time[inp$indest],1))
            clp <- exp(al1$annvec[inds])
            cup <- exp(al3$annvec[inds])
            inds <- which(!is.na(al2$annvec) & al2$anntime>=tail(inp$time[inp$indest],1))
            timep <- al1$anntime[inds]
            Fp <- exp(al2$annvec[inds])
            al1f <- annual(inp$time, logFF[, 1])
            al2f <- annual(inp$time, logFF[, 2])
            al3f <- annual(inp$time, logFF[, 3])
            inds <- which(!is.na(al1f$annvec))
            clf <- exp(al1f$annvec[inds])
            cuf <- exp(al3f$annvec[inds])
            inds <- which(!is.na(al2f$annvec))
            timef <- al2f$anntime[inds]
            Ff <- exp(al2f$annvec[inds])
        } else {
            time <- inp$time[inp$indest]
            cl <- FF[inp$indest, 1]
            F <- FF[inp$indest, 2]
            cu <- FF[inp$indest, 3]
            timep <- inp$time[inp$indpred]
            clp <- FF[inp$indpred, 1]
            Fp <- FF[inp$indpred, 2]
            cup <- FF[inp$indpred, 3]
            timef <- inp$time
            clf <- FF[, 1]
            Ff <- FF[, 2]
            cuf <- FF[, 3]
        }
        flag <- length(cu)==0
        if(flag){
            fininds <- which(is.finite(Ff))
            if(length(ylim)!=2) ylim <- range(c(Ff[fininds], 0.95*Fmsy[1]/Fmsy[2], 1.05*Fmsy[3]/Fmsy[2]), na.rm=TRUE)
        } else {
            fininds <- which(apply(cbind(clf, cuf), 1, function(x) all(is.finite(x))))
            if(length(ylim)!=2) ylim <- range(c(cl[fininds], cu[fininds], 0.95*Fmsy[1]/Fmsy[2], 1.05*Fmsy[3]/Fmsy[2]), na.rm=TRUE)
        }
        ylim[2] <- min(c(ylim[2], 3*max(Ff[fininds]))) # Limit upper limit
        #main <- paste('Fmsy:',round(Fmsy[2],3),' ffac:',inp$ffac)
        if(main==-1) main <- 'Relative fishing mortality'
        plot(timef, Ff, typ='n', main=main, ylim=ylim, col='blue', ylab=expression(F[t]/F[MSY]), xlab='Time', xlim=range(c(inp$time, tail(inp$time,1)+1)))
        #polygon(c(inp$time[1]-5,tail(inp$time,1)+5,tail(inp$time,1)+5,inp$time[1]-5), c(Fmsy[1]/Fmsy[2],Fmsy[1]/Fmsy[2],Fmsy[3]/Fmsy[2],Fmsy[3]/Fmsy[2]), col=cicol, border=cicol)
        #polygon(c(inp$time, rev(inp$time)), c(Fmsyvec$ll/Fmsyvec$msy,rev(Fmsyvec$ul/Fmsyvec$msy)), col=cicol, border=cicol)
        cicol2 <- rgb(0, 0, 1, 0.1)
        if(!flag) polygon(c(timef[fininds], rev(timef[fininds])), c(clf[fininds], rev(cuf[fininds])), col=cicol2, border=cicol2)
        if(min(inp$dtc) < 1){ # Plot estimated sub annual F 
            lines(inp$time, FF[, 2], col=rgb(0, 0, 0, 0.2))
        }
        abline(v=inp$time[inp$indlastobs], col='gray')
        if('true' %in% names(inp)){
            lines(inp$true$time, inp$true$Fs, col='orange') # Plot true
            abline(h=inp$true$Fmsy, col='orange', lty=2)
        }
        maincol <- 'blue'
        lines(time, F, col=maincol, lwd=1.5)
        lines(timep, Fp, col=maincol, lty=3)
        if(!flag) lines(timef, clf, col=rgb(0, 0, 1, 0.2))
        if(!flag) lines(timef, cuf, col=rgb(0, 0, 1, 0.2))
        #tp <- inp$time[inp$dtprediind]
        #points(tp, Fest[inp$dtprediind, 2], pch=21, bg='yellow')
        abline(h=1, col='black')
        #abline(h=rest[2], col='red')
        #if(plot.legend) legend('topleft',c(paste(tp,'Pred.')), pch=21, pt.bg=c('yellow'), bg='white')
        box(lwd=1.5)
    }
}


#' @name plotspict.fb
#' @title Plot fishing mortality versus biomass.
#' @details Plots estimated fishing mortality as a function of biomass together with reference points and the prediction for next year given a constant F. The equilibrium biomass for F fixed to the current value is also plotted.
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of x and y-axes? default: FALSE
#' @param plot.legend Plot legend explaining triangle.
#' @param ext Add relative level axis to top and right side.
#' @param rel.axes Plot axes in relative levels instead of absolute.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.fb(rep)
#' @export
plotspict.fb <- function(rep, logax=FALSE, plot.legend=TRUE, ext=TRUE, rel.axes=FALSE, xlim=NULL, ylim=NULL){
    if(!'sderr' %in% names(rep)){
        log <- ifelse(logax, 'xy', '')
        inp <- rep$inp
        Bmsyall <- get.par('logBmsy', rep, exp=TRUE)
        Fmsyall <- get.par('logFmsy', rep, exp=TRUE)
        Bmsy <- tail(Bmsyall, 1)
        Fmsy <- tail(Fmsyall, 1)
        if(rel.axes){
            ext <- FALSE
            bscal <- Bmsy[2]
            fscal <- Fmsy[2]
            xlab <- expression(B[t]/B[MSY])
            ylab <- expression(F[t]/F[MSY])
        } else {
            bscal <- 1
            fscal <- 1
            xlab <- expression(B[t])
            ylab <- expression(F[t])
        }
        cicol <- 'lightgray'
        Bp <- get.par('logBp', rep, exp=TRUE)
        Best <- get.par('logB', rep, exp=TRUE)
        logBest <- get.par('logB', rep)
        #Binf <- get.par('logBinf', rep, exp=TRUE)
        #inds <- which(is.na(Binf) | Binf<0)
        #Binf[inds] <- 1e-12
        #annlist <- annual(inp$time, Binf[, 2])
        #Binftime <- annlist$anntime
        #Binfs <- annlist$annvec
        ns <- dim(Best)[1]
        qest <- get.par('logq', rep, exp=TRUE)
        Fest <- get.par('logFs', rep, exp=TRUE)
        logFest <- get.par('logFs', rep)
        Fp <- Fest[ns,]
        inds <- c(max(which(names(rep$value)=='logBmsy')), max(which(names(rep$value)=='logFmsy')))
        cl <- make.ellipse(inds, rep)
        # Limits
        if(length(xlim)!=2){
            xlim <- range(c(exp(cl[,1]),Best[,2])/bscal, na.rm=TRUE)
            if(min(inp$dtc) < 1){
                alb <- annual(inp$time, logBest[, 2])
                # New annual limits
                xlim <- range(c(exp(alb$annvec)/bscal, exp(cl[, 1])/bscal), na.rm=TRUE)
            }
            xlim[2] <- min(c(xlim[2], 8*Bmsy[2]/bscal))
        }
        if(length(ylim)!=2){
            ylim <- range(c(exp(cl[,2]),Fest[,2])/fscal, na.rm=TRUE)
            if(min(inp$dtc) < 1){
                alf <- annual(inp$time, logFest[, 2])
                # New annual limits
                ylim <- range(c(exp(alf$annvec)/fscal, exp(cl[, 2])/fscal), na.rm=TRUE)
            }
            ylim[2] <- min(c(ylim[2], 8*Fmsy[2]/fscal))
        }
        # Plotting
        #par(mar=c(5,4,4,4))
        plot(Bmsy[2]/bscal, Fmsy[2]/fscal, typ='p', xlim=xlim, xlab=xlab, ylab=ylab,  pch=24, bg='blue', ylim=ylim, log=log)
        if(ext){
            axis(3, labels=pretty(xlim/Bmsy[2]), at=pretty(xlim/Bmsy[2])*Bmsy[2])
            mtext(expression(B[t]/B[MSY]), side=3, las=0, line=2, cex=par('cex'))
            axis(4, labels=pretty(ylim/Fmsy[2]), at=pretty(ylim/Fmsy[2])*Fmsy[2])
            mtext(expression(F[t]/F[MSY]), side=4, las=0, line=2.5, cex=par('cex'))
        }
        alpha <- 0.15
        polygon(c(Bmsy[2], Bmsy[2], xlim[2]*2, xlim[2]*2)/bscal, c(Fmsy[2], 0, 0, Fmsy[2])/fscal, col=rgb(0,0.8,0,alpha), border=NA) # Green
        polygon(c(Bmsy[2], Bmsy[2], 0, 0)/bscal, c(Fmsy[2], 0, 0, Fmsy[2])/fscal, col=rgb(1,1,0,alpha), border=NA) # Yellow
        polygon(c(Bmsy[2], Bmsy[2], xlim[2]*2, xlim[2]*2)/bscal, c(Fmsy[2], ylim[2]*2, ylim[2]*2, Fmsy[2])/fscal, col=rgb(1,1,0,alpha), border=NA) # Yellow
        polygon(c(Bmsy[2], Bmsy[2], 0, 0)/bscal, c(Fmsy[2], ylim[2]*2, ylim[2]*2, Fmsy[2])/fscal, col=rgb(0.6,0,0,alpha), border=NA) # Red
        cicol2 <- 'gray'
        polygon(exp(cl[,1])/bscal, exp(cl[,2])/fscal, col=cicol, border=cicol2)
        #abline(h=Fmsy[2], lty=1)
        #abline(v=Bmsy[2], lty=1)
        #arrow.line(Best[,2]/bscal, Fest[,2], length=0.05, col='blue')
        if('true' %in% names(inp)){
            #lines(inp$true$B/bscal, inp$true$F, col='orange') # Plot true
            points(inp$true$Bmsy/bscal, inp$true$Fmsy/fscal, pch=24, bg='orange')
        }
        maincol <- rgb(0,0,1,0.8)
        if(min(inp$dtc) < 1){
        #if(FALSE){
            aind <- which(inp$time[inp$dtprediind] == alb$anntime)
            bbb <- exp(alb$annvec)/bscal
            fff <- exp(alf$annvec)/fscal
            lines(bbb, fff, col=maincol, lwd=1.5)
            #points(alb$annvec[aind]/bscal, alf$annvec[aind], pch=21, bg='yellow')
            #points(tail(Binfs,1)/bscal, Fp[2], pch=22, bg='green', cex=2)
            #arrow.line(c(tail(alb$annvec,1), tail(Binfs,1))/bscal, rep(Fp[2],2), col='black', length=0.05)
        } else {
            bbb <- Best[inp$indest,2]/bscal
            fff <- Fest[inp$indest,2]/fscal
            lines(bbb, fff, col=maincol, lwd=1.5)
            lines(Best[inp$indpred,2]/bscal, Fest[inp$indpred,2]/fscal, col=maincol, lty=3)
            pind <- rep$inp$dtprediind
            #points(Best[pind,2]/bscal, Fest[pind,2], pch=21, bg='yellow')
            #points(tail(Binfs,1)/bscal, Fp[2]/fscal, pch=22, bg='green', cex=2)
            #arrow.line(c(tail(Best[,2],1), tail(Binfs,1))/bscal, rep(Fp[2],2)/fscal, col='black', length=0.05)
            #if(plot.legend) legend('topright', c('Estimated MSY',paste(inp$time[pind],'Pred.'),expression('E(B'[infinity]*')')), pch=c(24,21,22), pt.bg=c('black','yellow','green'), bg='white')
            #if(plot.legend) legend('topright', c('Estimated MSY',expression('E(B'[infinity]*')')), pch=c(24,22), pt.bg=c('black','green'), bg='white')
        }
        
        points(Bmsy[2]/bscal, Fmsy[2]/fscal, pch=24, bg='black')
        nr <- length(inp$ini$logr)
        if(nr > 1){
            points(Bmsyall[1:(nr-1), 2]/bscal, Fmsyall[1:(nr-1), 2]/fscal, pch=24, bg='magenta')
            if(plot.legend) legend('topright', c('Current MSY', 'Previous MSY'), pch=24, pt.bg=c('black', 'magenta'), bg='white')
        } else {
            if(plot.legend) legend('topright', c('Estimated MSY'), pch=c(24), pt.bg=c('black'), bg='white')
        }
        points(tail(bbb,1), tail(fff,1), pch=22, bg='red')
        points(bbb[1], fff[1], pch=21, bg='green')
        box(lwd=1.5)
    }
}


#' @name plotspict.catch
#' @title Plot observed catch and predictions.
#' @details Plots observed catch and predictions using the current F and Fmsy. The plot also contains the equilibrium catch if the current F is maintained.
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.catch(rep)
#' @export
plotspict.catch <- function(rep, main=-1, plot.legend=TRUE, ylim=NULL){
    if(!'sderr' %in% names(rep)){
        inp <- rep$inp
        Cscal <- 1
        cicol <- 'lightgray'
        MSY <- get.par('logMSY', rep, exp=TRUE)
        MSYvec <- get.msyvec(inp, MSY)
        Crc <- get.par('logCrcsum', rep, exp=TRUE)
        #Cpredsub <- get.par('Cpredsub', rep)
        Cpredest <- get.par('logCpred', rep, exp=TRUE)
        Cpredest[Cpredest<0] <- 0
        rep$Cp[rep$Cp<0] <- 0
        indest <- which(inp$timeCpred <= tail(inp$timeC,1))
        indpred <- which(inp$timeCpred >= tail(inp$timeC,1))
        dtc <- inp$dtcp
        if(min(inp$dtc) < 1){
        #if(FALSE){
            alo <- annual(inp$timeC, inp$obsC/inp$dtc)
            timeo <- alo$anntime
            obs <- alo$annvec
            al1 <- annual(inp$timeCpred[indest], Cpredest[indest, 1]/dtc[indest])
            al2 <- annual(inp$timeCpred[indest], Cpredest[indest, 2]/dtc[indest])
            al3 <- annual(inp$timeCpred[indest], Cpredest[indest, 3]/dtc[indest])
            inds <- which(!is.na(al2$annvec))
            time <- al2$anntime[inds]
            c <- al2$annvec[inds]
            cl <- al1$annvec[inds]
            cu <- al3$annvec[inds]
            al1p <- annual(inp$timeCpred[indpred], Cpredest[indpred, 1]/dtc[indpred])
            al2p <- annual(inp$timeCpred[indpred], Cpredest[indpred, 2]/dtc[indpred])
            al3p <- annual(inp$timeCpred[indpred], Cpredest[indpred, 3]/dtc[indpred])
            inds <- which(!is.na(al2p$annvec))
            timep <- al2p$anntime[inds]
            cp <- al2p$annvec[inds]
            clp <- al1p$annvec[inds]
            cup <- al3p$annvec[inds]
            al1f <- annual(inp$timeCpred, Cpredest[, 1]/dtc)
            al2f <- annual(inp$timeCpred, Cpredest[, 2]/dtc)
            al3f <- annual(inp$timeCpred, Cpredest[, 3]/dtc)
            inds <- which(!is.na(al2f$annvec))
            timef <- al2f$anntime[inds]
            clf <- al1f$annvec[inds]
            cf <- al2f$annvec[inds]
            cuf <- al3f$annvec[inds]
            if(any(inp$dtc==1)){
                inds <- which(inp$dtc==1)
                timeo <- c(timeo, inp$timeC[inds])
                obs <- c(obs, inp$obsC[inds])
                #time <- c(time, inp$timeCpred[inds])
                #c <- c(c, Cpredest[inds, 2])
                #cl <- c(cl, Cpredest[inds, 1])
                #cu <- c(cu, Cpredest[inds, 3])
                timeunsort <- c(time, inp$timeCpred[inds])
                timesort <- sort(timeunsort, index=TRUE)
                time <- timesort$x
                #obs <- c(obs, inp$obsC[inds])[timesort$ix]
                c <- c(c, Cpredest[inds, 2])[timesort$ix]
                cl <- c(cl, Cpredest[inds, 1])[timesort$ix]
                cu <- c(cu, Cpredest[inds, 3])[timesort$ix]
            }
        } else {
            timeo <- inp$timeC
            obs <- inp$obsC/inp$dtc
            time <- inp$timeCpred[indest]
            c <- Cpredest[indest, 2]/dtc[indest]
            cl <- Cpredest[indest, 1]
            cu <- Cpredest[indest, 3]
            timep <- inp$timeCpred[indpred]
            cp <- Cpredest[indpred, 2]/dtc[indpred]
            clp <- Cpredest[indpred, 1]
            cup <- Cpredest[indpred, 3]
            timef <- inp$timeCpred
            clf <- Cpredest[, 1]
            cf <- Cpredest[, 2]/dtc
            cuf <- Cpredest[, 3]
        }
        fininds <- which(apply(cbind(clf, cuf), 1, function(x) all(is.finite(x))))
        if(length(ylim)!=2){
            ylim <- range(c(cl, cu, 0.9*MSY[1], 1.07*MSY[3]), na.rm=TRUE)/Cscal
            if(inp$dtpredc > 0) ylim <- range(ylim, clf[fininds], cuf[fininds])
        }
        ylim[2] <- min(c(ylim[2], 3*max(cf[fininds]))) # Limit upper limit
        if(main==-1) main <- 'Catch'
        plot(time, c, typ='n', main=main, xlab='Time', ylab=paste('Catch'), xlim=range(c(inp$time, tail(inp$time,1))), ylim=ylim)
        #polygon(c(inp$time[1]-5,tail(inp$time,1)+5,tail(inp$time,1)+5,inp$time[1]-5), c(MSY[1],MSY[1],MSY[3],MSY[3])/Cscal, col=cicol, border=cicol)
        polygon(c(inp$time, rev(inp$time)), c(MSYvec$ll,rev(MSYvec$ul)), col=cicol, border=cicol)
        cicol2 <- rgb(0, 0, 1, 0.1)
        #polygon(c(timef, rev(timef)), c(clf, rev(cuf)), col=cicol2, border=cicol2)
        #lines(timef, clf, col=rgb(0, 0, 1, 0.2))
        #lines(timef, cuf, col=rgb(0, 0, 1, 0.2))
        lines(time, cl, col=4, lwd=1.5, lty=2)
        lines(time, cu, col=4, lwd=1.5, lty=2)
        abline(v=tail(inp$timeC,1), col='gray')
        #points(timeo, obs/Cscal, cex=0.7)
        plot.col(timeo, obs/Cscal, cex=0.7, do.line=FALSE, add=TRUE)
        #plot.col(inp$timeC, inp$obsC/Cscal, cex=0.7, do.line=FALSE, add=TRUE)
        # Highlight influential index observations
        if('infl' %in% names(rep) & min(inp$dtc) == 1){
            infl <- rep$infl$infl[1:inp$nobsC, ]
            cols <- apply(!is.na(infl), 1, sum)
            ncols <- length(unique(cols))
            inds <- which(cols>0)
            points(inp$timeC[inds], inp$obsC[inds]/Cscal, pch=21, cex=0.9, bg=cols[inds])
        }
        if('true' %in% names(inp)) abline(h=inp$true$MSY, col='orange', lty=2)
        #abline(h=MSY[2]/Cscal)
        lines(inp$time, MSYvec$msy)
        lines(time, c, col=4, lwd=1.5)
        if(inp$dtpredc > 0){
            lines(timep, cp, col=4, lty=3)
            lines(timep, clp, col=4, lwd=1, lty=2)
            lines(timep, cup, col=4, lwd=1, lty=2)
            points(inp$timepredc, Crc[2], pch=21, bg='yellow')
        }
        #if(min(inp$dtc) == 1 & plot.legend) legend('topleft',c(paste(tail(inp$timeCpred,1),'Pred.')), pch=21, pt.bg=c('yellow'), bg='white')
        if(min(inp$dtc) == 1 & plot.legend) legend('topright', 'C at Fmsy', pch=21, pt.bg=c('yellow'), bg='white')
        box(lwd=1.5)
    }
}


#' @name plotspict.production
#' @title Plot theoretical production curve and estimates.
#' @details Plots the theoretical production curve (production as a function of biomass) as calculated from the estimated model parameters. Overlaid is the estimated production/biomass trajectory.
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.production(rep)
#' @export
plotspict.production <- function(rep){
    if(!'sderr' %in% names(rep)){
        inp <- rep$inp
        Kest <- get.par('logK', rep, exp=TRUE)
        mest <- get.par('logm', rep, exp=TRUE)
        nr <- dim(mest)[1]
        gamma <- get.par('gamma', rep)
        n <- get.par('logn', rep, exp=TRUE)
        Bmsy <- get.par('logBmsy', rep, exp=TRUE)
        Bmsy <- c(1,1)
        nBplot <- 200
        Bplot <- seq(0.5*1e-8, Kest[2], length=nBplot)
        pfun <- function(gamma, m, K, n, B) gamma*m/K*B*(1 - (B/K)^(n-1))
        Pst <- list()
        for(i in 1:nr) Pst[[i]] <- pfun(gamma[2], mest[i,2], Kest[2], n[2], Bplot)
        ylim <- range(unlist(Pst)/Bmsy[2], na.rm=TRUE)
        if(inp$reportall & inp$nseasons==1){
            Best <- get.par('logB', rep, exp=TRUE)
            Pest <- get.par('P', rep)
            Bplot <- seq(0.5*min(c(1e-8, Best[, 2])), 1*max(c(Kest[2], Best[, 2])), length=nBplot)
            Bvec <- Best[inp$ic[1:dim(Pest)[1]], 2]
            ylim <- range(Pest[,2]/Bmsy[2], unlist(Pst)/Bmsy[2], na.rm=TRUE)
        }
        xlim <- range(Bplot/Kest[2], na.rm=TRUE)
        dt <- inp$dt[-1]
        inde <- inp$indest[-length(inp$indest)]
        indp <- inp$indpred[-1]-1
        plot(Bplot/Kest[2], Pst[[nr]]/Bmsy[2], typ='l', ylim=ylim, xlim=xlim, xlab='B/K', ylab='Production', col=1, main='Production curve')
        if(nr > 1) for(i in 1:(nr-1)) lines(Bplot/Kest[2], Pst[[i]]/Bmsy[2], col='gray')
        if(inp$reportall & inp$nseasons==1){
            lines(Bvec/Kest[2], Pest[, 2]/Bmsy[2], col=4, lwd=1.5)
        }
        mx <- (1/n[2])^(1/(n[2]-1))
        abline(v=mx, lty=3)
        abline(h=0, lty=3)
        box(lwd=1.5)
    }
}


#' @name plotspict.prodrate
#' @title Plot production rate as a function of biomass.
#' @details OBSOLETE!
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.prodrate(rep)
plotspict.prodrate <- function(rep){
    if(!'sderr' %in% names(rep)){
        inp <- rep$inp
        Best <- get.par('logB', rep, exp=TRUE)
        Kest <- get.par('logK', rep, exp=TRUE)
        rest <- get.par('logr', rep, exp=TRUE)
        nest <- get.par('logn', rep, exp=TRUE)
        Pest <- get.par('P', rep)
        inds <- unique(c(inp$ic, unlist(inp$ii)))
        B <- Best[-inp$ns,2]
        r <- rest[2]
        p <- nest[2]-1
        K <- Kest[2]
        pr <- r*(1-(B[inds]/K)^p)
        probs <- Pest[inds, 2]/inp$dt[inds]/B[inds]
        plot(B[inds], probs, typ='p', xlab='B', ylab='Production/B', col='blue', main=bquote(pseudoR^2 == .(round(rep$stats$pseudoRsq, 4))))
        lines(B[inds], pr)
        abline(h=0, lty=3)
        legend('topright', legend=c('Observed production/B', expression(r*(1-(B/K)^p))), col=c(4,1), pch=c(1,NA), lty=c(NA,1))
        box(lwd=1.5)
    }
}


#' @name plotspict.tc
#' @title Plot time constant.
#' @details Plots the time required for the biomass to reach a certain proportion of Bmsy. The time required to reach 95% of Bmsy is highlighted.
#' @param rep A result report as generated by running fit.spict.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.tc(rep)
#' @export
plotspict.tc <- function(rep){
    if(!'sderr' %in% names(rep)){
        inp <- rep$inp
        B0cur <- get.par('logBl', rep, exp=TRUE)[2]
        Kest <- get.par('logK', rep, exp=TRUE)
        m <- get.par('logm', rep, exp=TRUE)
        #mmean <- apply(m, 2, mean)[2]
        mmean <- tail(m, 1)[2]
        n <- get.par('logn', rep, exp=TRUE)
        gamma <- calc.gamma(n[2])
        sdbest <- get.par('logsdb', rep, exp=TRUE)
        Fmsy <- tail(get.par('logFmsy', rep, exp=TRUE), 1)
        Bmsy <- tail(get.par('logBmsy', rep, exp=TRUE), 1)
        if(B0cur < Bmsy[2]) do.flag <- ifelse(B0cur/Bmsy[2]>0.95, FALSE, TRUE)
        if(B0cur > Bmsy[2]) do.flag <- ifelse(Bmsy[2]/B0cur>0.95, FALSE, TRUE)
        if(do.flag){
            if(B0cur < Bmsy[2]) facvec <- c(0, 0.75, 0.95, 1)
            if(B0cur > Bmsy[2]) facvec <- c(2, 1.25, 1.05, 1)
            Fvec <- round(facvec*Fmsy[2], digits=4)
            nFvec <- length(Fvec)
            g <- function(F, K, m, n, sdb, B0, dt){
                return(exp( log(B0) + (gamma*m/K - gamma*m/K*(B0/K)^(n-1) - F - 0.5*sdb^2)*dt ))
            }
            simdt <- 0.01
            nt <- 10000
            Bsim <- matrix(0, nFvec, nt)
            time <- matrix(0, nFvec, nt)
            for(i in 1:nFvec){
                time[i, ] <- seq(0, simdt*(nt-1), by=simdt)
                Bsim[i, ] <- rep(0, nt)
                Bsim[i, 1] <- B0cur
                for(j in 2:nt){
                    Bsim[i, j] <- g(Fvec[i], Kest[2], mmean, n[2], sdbest[2], Bsim[i, j-1], simdt)
                }
            }
            Bsim <- Bsim/Bmsy[2]
            frac <- 0.95
            if(B0cur < Bmsy[2]) inds <- which(Bsim[nFvec, ]<0.99)
            if(B0cur > Bmsy[2]) inds <- which(Bsim[nFvec, ]>(1/0.99))
            ylim <- range(Bsim[nFvec, ], na.rm=TRUE)
            xlim <- range(time[nFvec, inds])
            xlim[2] <- min(xlim[2], 15) # Max 15 years ahead
            plot(time[1, ], Bsim[1, ], typ='l', xlim=xlim, ylim=ylim, col=3, ylab='Proportion of Bmsy', xlab='Years to Bmsy', main='Time to Bmsy')
            abline(h=c(frac, 1/frac), lty=1, col='lightgray')
            abline(h=1, lty=3)
            for(i in 2:nFvec) lines(time[i, ], Bsim[i, ], col=i+2)
            vt <- rep(0, nFvec)
            if(B0cur < Bmsy[2]) for(i in 1:nFvec) vt[i] <- time[i, max(which(Bsim[i, ]<frac))]
            if(B0cur > Bmsy[2]) for(i in 1:nFvec) vt[i] <- time[i, max(which(1/Bsim[i, ]<frac))]
            for(i in 1:nFvec) abline(v=vt[i], col=i+2, lty=2)
            lgnplace <- 'bottomright'
            if(B0cur > Bmsy[2]) lgnplace <- 'topright'
            legend(lgnplace, legend=paste('F =',facvec,'x Fmsy'), lty=1, col=2+(1:nFvec), lwd=rep(1,nFvec), bg='white')
            points(vt, rep(par('usr')[3], nFvec), col=3:(nFvec+2), pch=4)
        }
        box(lwd=1.5)
    }
}

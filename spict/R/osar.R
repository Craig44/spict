#' @name calc.osa.resid
#' @title Calculate one-step-ahead residuals.
#' @details In TMB one-step-ahead residuals are calculated by sequentially including one data point at a time while keeping the model parameters fixed at their ML estimates. The calculated residuals are tested for independence in lag 1 using the Ljung-Box test (see Box.test).
#' @param rep A result report as generated by running fit.spict.
#' @param dbg Does nothing. Only preserved for backward compatibility with old osar function.
#' @return An updated result report, which contains one-step-ahead residuals stored in $osarC and $osarI.
#' @export
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' rep <- calc.osa.resid(rep)
#' plotspict.osar(rep)
#' @import TMB
calc.osa.resid <- function(rep, dbg=0){
    inp <- rep$inp
    # - Built-in OSAR -
    if(rep$inp$osar.method == 'none'){
        rep$inp$osar.method <- 'oneStepGaussian'
    }
    osar <- oneStepPredict(rep$obj, observation.name = "obssrt", data.term.indicator='keep', method=rep$inp$osar.method, discrete=FALSE, subset=rep$inp$subset, trace=FALSE, parallel=TRUE)
    osar <- cbind(id=inp$obsidsrt[inp$subset], osar)
    # Store catch residuals separately
    inds <- match(inp$obsidC, osar$id)
    inds <- inds[!is.na(inds)]
    rep$osarC <- osar[inds, ]
    inds2 <- match(osar$id, inp$obsidC)
    inds2 <- inds2[!is.na(inds2)]
    timeC <- inp$timeC[inds2]
    # Store index residuals separately
    rep$osarI <- list()
    timeI <- list()
    for(i in 1:rep$inp$nindex){
        inds <- match(inp$obsidI[[i]], osar$id)
        inds <- inds[!is.na(inds)]
        rep$osarI[[i]] <- osar[inds,]
        inds2 <- match(osar$id, inp$obsidI[[i]])
        inds2 <- inds2[!is.na(inds2)]
        timeI[[i]] <- inp$timeI[[i]][inds2]
    }

    npar <- length(rep$opt$par)
    # Catches
    logCpres <- rep$osarC$residual
    logCpres[1] <- NA # Always omit first residual because it can be difficult to calculate
    lblag <- npar+1 # Lags to check with LB test
    logCpboxtest <- Box.test(logCpres, lag=lblag, type='Ljung-Box', fitdf=npar) # Test for independence of residuals
    logCpp5boxtest <- Box.test(logCpres, lag=lblag+4, type='Ljung-Box', fitdf=npar) # Test for independence of residuals
    logCpsqboxtest <- Box.test(logCpres^2, lag=lblag, type='Ljung-Box', fitdf=npar) # Test for independence of residuals
    logCpshapiro <- shapiro.test(logCpres) # Test for normality of residuals
    logCpbias <- t.test(logCpres) # Test for bias of residuals
    #rep$stats$ljungboxC.p <- logCpboxtest$p.value
    #rep$stats$ljungboxCp5.p <- logCpp5boxtest$p.value
    #rep$stats$ljungboxCsq.p <- logCpsqboxtest$p.value
    rep$stats$shapiroC.p <- logCpshapiro$p.value
    rep$stats$biasC.p <- logCpbias$p.value
    # Indices
    logIpres <- list()
    logIpboxtest <- list()
    logIpp5boxtest <- list()
    logIpsqboxtest <- list()
    logIpshapiro <- list()
    logIpbias <- list()
    for(i in 1:inp$nindex){
        logIpres[[i]] <- rep$osarI[[i]]$residual
        logIpres[[i]][1] <- NA # Always omit first residual because it can be difficult to calculate
        #logIpboxtest[[i]] <- Box.test(logIpres[[i]], lag=lblag, type='Ljung-Box', fitdf=npar)
        #logIpp5boxtest[[i]] <- Box.test(logIpres[[i]]^2, lag=lblag+4, type='Ljung-Box', fitdf=npar)
        #logIpsqboxtest[[i]] <- Box.test(logIpres[[i]]^2, lag=lblag, type='Ljung-Box', fitdf=npar)
        logIpshapiro[[i]] <- shapiro.test(logIpres[[i]])
        logIpbias[[i]] <- t.test(logIpres[[i]])
        nam <- paste0('ljungboxI', i, '.p')
        #rep$stats[[nam]] <- logIpboxtest[[i]]$p.value
        nam <- paste0('ljungboxIp5', i, '.p')
        #rep$stats[[nam]] <- logIpp5boxtest[[i]]$p.value
        nam <- paste0('ljungboxIsq', i, '.p')
        #rep$stats[[nam]] <- logIpsqboxtest[[i]]$p.value
        nam <- paste0('shapiroI', i, '.p')
        rep$stats[[nam]] <- logIpshapiro[[i]]$p.value
        nam <- paste0('biasI', i, '.p')
        rep$stats[[nam]] <- logIpbias[[i]]$p.value
    }
    rep$osar <- list(timeC=timeC, logCpres=logCpres, logCpbias=logCpbias, logCpshapiro=logCpshapiro, timeI=timeI, logIpres=logIpres, logIpshapiro=logIpshapiro, logIpbias=logIpbias)
    return(rep)
}



#' @name calc.osa.resid.old.new
#' @title Calculate one-step-ahead residuals.
#' @details In TMB one-step-ahead residuals are calculated by sequentially including one data point at a time while keeping the model parameters fixed at their ML estimates. The calculated residuals are tested for independence in lag 1 using the Ljung-Box test (see Box.test).
#' @param rep A result report as generated by running fit.spict.
#' @param dbg Debugging option. Will print out runtime information useful for debugging if set to 1. Will print even more if set to 2.
#' @return An updated result report, which contains one-step-ahead residuals stored in the $osar variable.
#' @export
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' rep <- calc.osa.resid(rep)
#' plotspict.osar(rep)
#' @import TMB
calc.osa.resid.old.new <- function(rep, dbg=0){
    get.predmap <- function(guess, RE){
        FE <- setdiff(names(guess), RE)
        predmapout <- list()
        for(nm in FE) predmapout[[nm]] <- factor(rep(NA, length(rep$inp$parlist[[nm]])))
        return(predmapout)
    }
    inp <- rep$inp
    inp$ffac <- 1
    if("logF" %in% names(inp$ini)) inp$ini$logF <- NULL
    if("logB" %in% names(inp$ini)) inp$ini$logB <- NULL
    if("ns" %in% names(inp)) inp$ns <- NULL
    predmap <- get.predmap(rep$pl, inp$RE)
    predmap$dum <- NULL # Keep dummy parameter free, but fix all other FE
    plnew <- rep$pl

    ### --- CATCHES --- ###
    logCpred <- rep(0, inp$nobsC-1)
    sdlogCpred <- rep(0, inp$nobsC-1)
    for(j in 2:inp$nobsC){
        cat('Catch OSAR step:', j, '- ')
        inp2 <- inp
        cinds <- which(inp$timeC < inp$timeC[j])
        inp2$obsC <- inp$obsC[cinds]
        inp2$timeC <- inp$timeC[cinds]
        inp2$dtc <- inp$dtc[cinds]
        inp2$dtpredc <- inp$dtc[j]
        inp2$obsI <- list()
        inp2$timeI <- list()
        for(i in inp$nindex){
            iinds <- which(inp$timeI[[i]] <= inp$timeC[j]) # It is OK to include index observations in the beginning of the catch interval
            inp2$obsI[[i]] <- inp$obsI[[i]][iinds]
            inp2$timeI[[i]] <- inp$timeI[[i]][iinds]
        }
        inp2$dtpredi <- 0
        inp2 <- check.inp(inp2)
        datnew <- list(reportall=0, dt=inp2$dt, dtpredcinds=inp2$dtpredcinds, dtpredcnsteps=inp2$dtpredcnsteps, dtprediind=inp2$dtprediind, indlastobs=inp2$indlastobs, obsC=inp2$obsC, ic=inp2$ic, nc=inp2$nc, I=inp2$obsIin, ii=inp2$iiin, iq=inp2$iqin, ir=inp$ir, seasons=inp2$seasons, seasonindex=inp2$seasonindex, splinemat=inp2$splinemat, ffac=inp$ffaceuler, indpred=inp2$indpred, robflagc=inp2$robflagc, robflagi=inp2$robflagi, lamperti=inp2$lamperti, euler=inp2$euler, stochmsy=ifelse(inp$msytype=='s', 1, 0), priorr=inp$priors$logr, priorm=inp$priors$logm, priorK=inp$priors$logK, priorbkfrac=inp$priors$logbkfrac, priorB=inp$priors$logB, dbg=dbg)
        for(k in 1:length(inp2$RE)) plnew[[inp2$RE[k]]] <- rep$pl[[inp2$RE[k]]][1:inp2$ns]
        objpred <- TMB::MakeADFun(data=datnew, parameters=plnew, map=predmap, random=inp2$RE, DLL=inp2$scriptname, hessian=TRUE, tracemgc=FALSE)
        verbose <- FALSE
        objpred$env$tracemgc <- verbose
        objpred$env$inner.control$trace <- verbose
        objpred$env$silent <- ! verbose
        val <- objpred$fn()
        if(!is.na(val)){
            sdr <- sdreport(objpred)
            logCpred[j-1] <- get.par('logCp', sdr)[2]
            sdlogCpred[j-1] <- get.par('logCp', sdr)[4]
        }
    }
    logCpres <- (log(inp$obsC[-1]) - logCpred)/sdlogCpred
    timeC <- inp$timeC[-1]

    ### --- INDICES --- ###
    cat('\n\n')
    timeobs <- sort(unique(unlist(inp$timeI)))
    timepred <- timeobs[-1] # Times where observations must be predicted
    npred <- length(timepred)
    obsmat <- matrix(0, npred, inp$nindex) # Collect all observations in a matrix
    haveobs <- matrix(0, npred, inp$nindex) # Indicate which observations are available at timepred
    for(i in 1:inp$nindex){
        iim <- na.omit(match(inp$timeI[[i]], timepred))
        ii <- na.omit(match(timepred, inp$timeI[[i]]))
        obsmat[iim, i] <- inp$obsI[[i]][ii] # Put I in obsmat
        haveobs[iim, i] <- 1
    }
    logpredmat <- matrix(0, npred, inp$nindex) # Collect sdreport prediction in this matrix
    sdlogpredmat <- matrix(0, npred, inp$nindex) # Collect sd of prediction in this matrix
    for(j in 1:npred){
        cat('Index OSAR step:', j, '- ')
        inp2 <- inp
        cinds <- which((inp$timeC+inp$dtc) < timepred[j]) # Catch intervals ending at the index observations are not included
        inp2$obsC <- inp$obsC[cinds]
        inp2$timeC <- inp$timeC[cinds]
        inp2$dtc <- inp$dtc[cinds]
        inp2$dtpredc <- 0
        inp2$obsI <- list()
        inp2$timeI <- list()
        for(i in 1:inp$nindex){
            iinds <- which(inp$timeI[[i]] < timepred[j])
            inp2$obsI[[i]] <- inp$obsI[[i]][iinds]
            inp2$timeI[[i]] <- inp$timeI[[i]][iinds]
        }
        inp2$dtpredi <- timepred[j] - timeobs[j]
        inp2 <- check.inp(inp2)
        datnew <- list(reportall=0, dt=inp2$dt, dtpredcinds=inp2$dtpredcinds, dtpredcnsteps=inp2$dtpredcnsteps, dtprediind=inp2$dtprediind, indlastobs=inp2$indlastobs, obsC=inp2$obsC, ic=inp2$ic, nc=inp2$nc, I=inp2$obsIin, ii=inp2$iiin, iq=inp2$iqin, ir=inp$ir, seasons=inp2$seasons, seasonindex=inp2$seasonindex, splinemat=inp2$splinemat, ffac=inp$ffaceuler, indpred=inp2$indpred, robflagc=inp2$robflagc, robflagi=inp2$robflagi, lamperti=inp2$lamperti, euler=inp2$euler, stochmsy=ifelse(inp$msytype=='s', 1, 0), priorr=inp$priors$logr, priorm=inp$priors$logm, priorK=inp$priors$logK, priorbkfrac=inp$priors$logbkfrac, priorB=inp$priors$logB, dbg=dbg)
        for(k in 1:length(inp2$RE)) plnew[[inp2$RE[k]]] <- rep$pl[[inp2$RE[k]]][1:inp2$ns]
        objpred <- TMB::MakeADFun(data=datnew, parameters=plnew, map=predmap, random=inp2$RE, DLL=inp2$scriptname, hessian=TRUE, tracemgc=FALSE)
        verbose <- FALSE
        objpred$env$tracemgc <- verbose
        objpred$env$inner.control$trace <- verbose
        objpred$env$silent <- ! verbose
        val <- objpred$fn()
        if(!is.na(val)){
            sdr <- sdreport(objpred)
            # Collect index prediction(s) (column number > 1 are indices)
            for(i in 1:inp$nindex){
                if(haveobs[j, i] == 1){
                    logpredmat[j, i] <- get.par('logIp', sdr)[i, 2]
                    sdlogpredmat[j, i] <- get.par('logIp', sdr)[i, 4]
                }
            }
        }
    }
    logIpred <- list()
    sdlogIpred <- list()
    logIpres <- list()
    timeI <- list()
    for(i in 1:inp$nindex){
        logIpred[[i]] <- rep(0, inp$nobsI[i]-1)
        sdlogIpred[[i]] <- rep(0, inp$nobsI[i]-1)
        inds <- which(haveobs[, i]==1)
        timeI[[i]] <- timepred[inds]
        logIpred[[i]] <- logpredmat[inds, i]
        sdlogIpred[[i]] <- sdlogpredmat[inds, i]
        logIpres[[i]] <- (log(obsmat[inds, i]) - logIpred[[i]])/sdlogIpred[[i]]
        logIpres[[i]][!is.finite(logIpres[[i]])] <- NA
    }

    ### --- POST PROCESSING RESIDUALS --- ###
    # Catches
    logCpshapiro <- shapiro.test(logCpres) # Test for normality of residuals
    logCpbias <- t.test(logCpres) # Test for bias of residuals
    rep$stats$shapiroC.p <- logCpshapiro$p.value
    rep$stats$biasC.p <- logCpbias$p.value
    # Indices
    logIpshapiro <- list()
    logIpbias <- list()
    for(i in 1:inp$nindex){
        logIpshapiro[[i]] <- shapiro.test(logIpres[[i]])
        logIpbias[[i]] <- t.test(logIpres[[i]])
        nam <- paste0('shapiroI', i, '.p')
        rep$stats[[nam]] <- logIpshapiro[[i]]$p.value
        nam <- paste0('biasI', i, '.p')
        rep$stats[[nam]] <- logIpbias[[i]]$p.value
    }

    rep$osar <- list(logCpres=logCpres, logCpred=logCpred, sdlogCpred=sdlogCpred, timeC=timeC, logCpbias=logCpbias, logCpshapiro=logCpshapiro, timeI=timeI, logIpres=logIpres, logIpred=logIpred, sdlogIpred=sdlogIpred, logIpshapiro=logIpshapiro, logIpbias=logIpbias)
    return(rep)
}


#' @name calc.osa.resid.old
#' @title Calculate one-step-ahead residuals.
#' @details In TMB one-step-ahead residuals are calculated by sequentially including one data point at a time while keeping the model parameters fixed at their ML estimates. The calculated residuals are tested for independence in lag 1 using the Ljung-Box test (see Box.test).
#' @param rep A result report as generated by running fit.spict.
#' @param dbg Debugging option. Will print out runtime information useful for debugging if set to 1. Will print even more if set to 2.
#' @return An updated result report, which contains one-step-ahead residuals stored in the $osar variable.
#' @export
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' rep <- calc.osa.resid(rep)
#' plotspict.osar(rep)
#' @import TMB
calc.osa.resid.old <- function(rep, dbg=0){
    get.predmap <- function(guess, RE){
        FE <- setdiff(names(guess), RE)
        predmapout <- list()
        for(nm in FE) predmapout[[nm]] <- factor(rep(NA, length(rep$inp$parlist[[nm]])))
        return(predmapout)
    }
    inp <- rep$inp
    inp$timepredc <- NULL
    inp$ffac <- 1
    if("logF" %in% names(inp$ini)) inp$ini$logF <- NULL
    if("logB" %in% names(inp$ini)) inp$ini$logB <- NULL
    if("ns" %in% names(inp)) inp$ns <- NULL
    predmap <- get.predmap(rep$pl, inp$RE)
    predmap$dum <- NULL # Keep dummy parameter free, but fix all other FE
    plnew <- rep$pl
    #logCpred <- rep(0, inp$nobsC-1)
    #logIpred <- list()
    #delay <- inp$dteuler # Delay in years
    #timeobs <- inp$timeC
    #for(i in 1:inp$nindex){
    #    logIpred[[i]] <- rep(0, inp$nobsI[i]-1)
    #    timeobs <- c(timeobs, inp$timeI[[i]])
    #}
    #timeobs <- sort(unique(timeobs)) # Times where observations are available
    timeobs <- sort(unique(c(inp$timeC, unlist(inp$timeI))))
    inds <- which(timeobs >= (timeobs[1]+inp$dteuler))
    #inds <- which(timeobs >= (timeobs[2]+delay)) # Start from 2: skip first observation because the RE are set to the FE bkfrac and F0.
    timepred <- timeobs[inds] # Times where observations must be predicted
    npred <- length(timepred)
    nser <- inp$nindex+1 # Number of data series
    obsmat <- matrix(0, npred, nser) # Collect all observations in a matrix
    haveobs <- matrix(0, npred, nser) # Indicate which observations are available at timepred
    dtc <- rep(0, npred)
    #rm.na <- function(rr) rr[!is.na(rr)]
    #icm <- rm.na(match(inp$timeC, timepred))
    #ic <- rm.na(match(timepred, inp$timeC))
    icm <- na.omit(match(inp$timeC, timepred))
    ic <- na.omit(match(timepred, inp$timeC))
    obsmat[icm, 1] <- inp$obsC[ic] # Put C in obsmat
    dtc[icm] <- inp$dtc[ic]
    haveobs[icm, 1] <- 1
    for(i in 1:inp$nindex){
        #iim <- rm.na(match(inp$timeI[[i]], timepred))
        #ii <- rm.na(match(timepred, inp$timeI[[i]]))
        iim <- na.omit(match(inp$timeI[[i]], timepred))
        ii <- na.omit(match(timepred, inp$timeI[[i]]))
        obsmat[iim, i+1] <- inp$obsI[[i]][ii] # Put I in obsmat
        haveobs[iim, i+1] <- 1
    }
    logpredmat <- matrix(0, npred, nser) # Collect sdreport prediction in this matrix
    sdlogpredmat <- matrix(0, npred, nser) # Collect sd of prediction in this matrix

    for(j in 1:npred){
        cat('OSAR step:', j, '- ')
        inp2 <- inp
        endtimes <- rep(-1, nser) # Times of last observations of all data series
        # Catch
        cind <- which(inp$timeC < timepred[j])
        inp2$timeC <- inp$timeC[cind]
        if(length(cind)>0) endtimes[1] <- tail(inp2$timeC,1)
        inp2$obsC <- inp$obsC[cind]
        inp2$dtc <- inp$dtc[cind]
        cindm <- which(inp$timeC == timepred[j]) # C index of prediction
        if(length(cindm)==1) obsmat[j, 1] <- inp$obsC[cindm] # Store observed at pred time
        # Indices
        for(i in 1:inp$nindex){
            iind <- which(inp$timeI[[i]] < timepred[j])
            inp2$timeI[[i]] <- inp$timeI[[i]][iind]
            if(length(iind)>0) endtimes[i+1] <- tail(inp2$timeI[[i]],1)
            inp2$obsI[[i]] <- inp$obsI[[i]][iind]
            iindm <- which(inp$timeI[[i]] == timepred[j])
            if(length(iindm)==1) obsmat[j, i+1] <- inp$obsI[[i]][iindm]
        }
        inp2$dtpredc <- dtc[j]
        inp2$dtpredi <- timepred[j] - max(endtimes)
        #if(haveobs[j, 1] == 1) if(inp2$dtpredc < inp$dtc[which(inp$timeC == timepred[j])]) stop('Cannot calculate OSAR because index has a finer time step than catch. This needs to be implemented!')
        #if(haveobs[j, 1] == 1) if(inp2$dtpredc < inp$dtc[cindm]) stop('Cannot calculate OSAR because index has a finer time step than catch. This needs to be implemented!')
        inp2$ir <- NULL # Remove ir from inp2, but use inp$ir as input (see below)
        inp2 <- check.inp(inp2)
        datnew <- list(reportall=0, dt=inp2$dt, dtpredcinds=inp2$dtpredcinds, dtpredcnsteps=inp2$dtpredcnsteps, dtprediind=inp2$dtprediind, indlastobs=inp2$indlastobs, obsC=inp2$obsC, ic=inp2$ic, nc=inp2$nc, I=inp2$obsIin, ii=inp2$iiin, iq=inp2$iqin, ir=inp$ir, seasons=inp2$seasons, seasonindex=inp2$seasonindex, splinemat=inp2$splinemat, ffac=inp$ffaceuler, indpred=inp2$indpred, robflagc=inp2$robflagc, robflagi=inp2$robflagi, lamperti=inp2$lamperti, euler=inp2$euler, stochmsy=ifelse(inp$msytype=='s', 1, 0), priorr=inp$priors$logr, priorm=inp$priors$logm, priorK=inp$priors$logK, priorbkfrac=inp$priors$logbkfrac, priorB=inp$priors$logB, dbg=dbg)
        for(k in 1:length(inp2$RE)) plnew[[inp2$RE[k]]] <- rep$pl[[inp2$RE[k]]][1:inp2$ns]
        objpred <- TMB::MakeADFun(data=datnew, parameters=plnew, map=predmap, random=inp2$RE, DLL=inp2$scriptname, hessian=TRUE, tracemgc=FALSE)
        #objpred <- TMB::MakeADFun(data=datnew, parameters=plnew, map=inp$map[[length(inp$map)]], random=inp2$RE, DLL=inp2$scriptname, hessian=TRUE, tracemgc=FALSE)
        verbose <- FALSE
        objpred$env$tracemgc <- verbose
        objpred$env$inner.control$trace <- verbose
        objpred$env$silent <- ! verbose
        objpred$fn()
        sdr <- sdreport(objpred)
        # Collect catch prediction (first colum of haveobs is catches)
        if(haveobs[j, 1] == 1){
            #if(inp2$dtpredc >= inp$dtc[cindm]){
                logpredmat[j, 1] <- get.par('logCp', sdr)[2]
                sdlogpredmat[j, 1] <- get.par('logCp', sdr)[4]
            #} else {
            #    logpredmat[j, 1] <- NA
            #    sdlogpredmat[j, 1] <- NA
            #}
        }
        # Collect index prediction(s) (column number > 1 are indices)
        for(i in 1:inp$nindex){
            if(haveobs[j, i+1] == 1){
                logpredmat[j, i+1] <- get.par('logIp', sdr)[i, 2]
                sdlogpredmat[j, i+1] <- get.par('logIp', sdr)[i, 4]
            }
        }
    }
    npar <- length(rep$opt$par)
    # Catches
    if(any(is.na(logpredmat[, 1]))) cat('\nWARNING: Cannot calculate OSAR for catches because index has a finer time step than catch.\n')
    inds <- which(haveobs[, 1]==1)
    timeC <- timepred[inds]
    logCpred <- logpredmat[inds, 1]
    sdlogCpred <- sdlogpredmat[inds, 1]
    logCpres <- (log(obsmat[inds, 1]) - logCpred)/sdlogCpred
    lblag <- npar+1 # Lags to check with LB test
    logCpboxtest <- Box.test(logCpres, lag=lblag, type='Ljung-Box', fitdf=npar) # Test for independence of residuals
    logCpp5boxtest <- Box.test(logCpres, lag=lblag+4, type='Ljung-Box', fitdf=npar) # Test for independence of residuals
    logCpsqboxtest <- Box.test(logCpres^2, lag=lblag, type='Ljung-Box', fitdf=npar) # Test for independence of residuals
    logCpshapiro <- shapiro.test(logCpres) # Test for normality of residuals
    logCpbias <- t.test(logCpres) # Test for bias of residuals
    #rep$stats$ljungboxC.p <- logCpboxtest$p.value
    #rep$stats$ljungboxCp5.p <- logCpp5boxtest$p.value
    #rep$stats$ljungboxCsq.p <- logCpsqboxtest$p.value
    rep$stats$shapiroC.p <- logCpshapiro$p.value
    rep$stats$biasC.p <- logCpbias$p.value
    # Indices
    timeI <- list()
    logIpred <- list()
    sdlogIpred <- list()
    logIpres <- list()
    logIpboxtest <- list()
    logIpp5boxtest <- list()
    logIpsqboxtest <- list()
    logIpshapiro <- list()
    logIpbias <- list()
    for(i in 1:inp$nindex){
        inds <- which(haveobs[, i+1]==1)
        timeI[[i]] <- timepred[inds]
        logIpred[[i]] <- logpredmat[inds, i+1]
        sdlogIpred[[i]] <- sdlogpredmat[inds, i+1]
        logIpres[[i]] <- (log(obsmat[inds, i+1]) - logIpred[[i]])/sdlogIpred[[i]]
        #logIpboxtest[[i]] <- Box.test(logIpres[[i]], lag=lblag, type='Ljung-Box', fitdf=npar)
        #logIpp5boxtest[[i]] <- Box.test(logIpres[[i]]^2, lag=lblag+4, type='Ljung-Box', fitdf=npar)
        #logIpsqboxtest[[i]] <- Box.test(logIpres[[i]]^2, lag=lblag, type='Ljung-Box', fitdf=npar)
        logIpshapiro[[i]] <- shapiro.test(logIpres[[i]])
        logIpbias[[i]] <- t.test(logIpres[[i]])
        nam <- paste0('ljungboxI', i, '.p')
        #rep$stats[[nam]] <- logIpboxtest[[i]]$p.value
        nam <- paste0('ljungboxIp5', i, '.p')
        #rep$stats[[nam]] <- logIpp5boxtest[[i]]$p.value
        nam <- paste0('ljungboxIsq', i, '.p')
        #rep$stats[[nam]] <- logIpsqboxtest[[i]]$p.value
        nam <- paste0('shapiroI', i, '.p')
        rep$stats[[nam]] <- logIpshapiro[[i]]$p.value
        nam <- paste0('biasI', i, '.p')
        rep$stats[[nam]] <- logIpbias[[i]]$p.value
    }
    #rep$osar <- list(logCpres=logCpres, logCpred=logCpred, sdlogCpred=sdlogCpred, timeC=timeC, logCpboxtest=logCpboxtest, logCpbias=logCpbias, logCpshapiro=logCpshapiro, timeI=timeI, logIpres=logIpres, logIpred=logIpred, sdlogIpred=sdlogIpred, logIpboxtest=logIpboxtest, logIpshapiro=logIpshapiro, logIpbias=logIpbias)
    rep$osar <- list(logCpres=logCpres, logCpred=logCpred, sdlogCpred=sdlogCpred, timeC=timeC, logCpbias=logCpbias, logCpshapiro=logCpshapiro, timeI=timeI, logIpres=logIpres, logIpred=logIpred, sdlogIpred=sdlogIpred, logIpshapiro=logIpshapiro, logIpbias=logIpbias)
    return(rep)
}


#' @name get.osar.pvals
#' @title Gets the p-values of one-step-ahead residuals for all data series.
#' @details TBA
#' @param rep A valid result from fit.spict().
#' @return A vector containing the p-values.
get.osar.pvals <- function(rep){
    osarI <- unlist(rep$osar$logIpboxtest)
    inds <- which(names(osarI)=='p.value')
    return(c(rep$osar$logCpboxtest$p.value, as.numeric(osarI[inds])))
}

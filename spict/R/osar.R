# Stochastic surplus Production model in Continuous-Time (SPiCT)
#    Copyright (C) 2015  Martin Waever Pedersen, mawp@dtu.dk or wpsgodd@gmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' @name calc.osa.resid
#' @title Calculate one-step-ahead residuals.
#' @details In TMB one-step-ahead residuals are calculated by sequentially including one data point at a time while keeping the model parameters fixed at their ML estimates. The calculated residuals are tested for independence in lag 1 using the Ljung-Box test (see Box.test).
#' @param rep A result report as generated by running fit.spict.
#' @param silent If true nothing will be printed.
#' @param dbg Does nothing. Only preserved for backward compatibility with old osar function.
#' @return An updated result report, which contains one-step-ahead residuals stored in $osarC and $osarI.
#' @export
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' rep <- calc.osa.resid(rep)
#' plotspict.osar(rep)
#' @import TMB
calc.osa.resid <- function(rep, dbg=0){
    inp <- rep$inp
    # - Built-in OSAR -
    if(rep$inp$osar.method == 'none'){
        rep$inp$osar.method <- 'oneStepGaussian'
    }
    if(inp$osar.trace) cat('Number of OSAR steps:', length(rep$inp$osar.subset), '\n')
    osar <- try(oneStepPredict(rep$obj, observation.name = "obssrt", data.term.indicator='keep', method=rep$inp$osar.method, discrete=FALSE, conditional=rep$inp$osar.conditional, subset=rep$inp$osar.subset, trace=inp$osar.trace, parallel=inp$osar.parallel))
    if(class(osar) != 'try-error'){
        osar <- cbind(id=inp$obsidsrt[inp$osar.subset], osar)
        # Store catch residuals separately
        inds <- match(inp$obsidC, osar$id)
        inds <- inds[!is.na(inds)]
        rep$osarC <- osar[inds, ]
        inds2 <- match(osar$id, inp$obsidC)
        inds2 <- inds2[!is.na(inds2)]
        timeC <- inp$timeC[inds2]
        # Store index residuals separately
        rep$osarI <- list()
        timeI <- list()
        for(i in 1:rep$inp$nindex){
            inds <- match(inp$obsidI[[i]], osar$id)
            inds <- inds[!is.na(inds)]
            rep$osarI[[i]] <- osar[inds,]
            inds2 <- match(osar$id, inp$obsidI[[i]])
            inds2 <- inds2[!is.na(inds2)]
            timeI[[i]] <- inp$timeI[[i]][inds2]
        }

        npar <- length(rep$opt$par)
        # Catches
        logCpres <- rep$osarC$residual
        nna <- sum(is.na(logCpres))
        if(nna > 5) cat('Warning:', nna, 'NAs found in catch residuals\n')
        nnotna <- sum(!is.na(logCpres))
        if(nnotna > 5){
            lblag <- npar+1 # Lags to check with LB test
            logCpboxtest <- Box.test(logCpres, lag=lblag, type='Ljung-Box', fitdf=npar) # Test for independence of residuals
            logCpp5boxtest <- Box.test(logCpres, lag=lblag+4, type='Ljung-Box', fitdf=npar) # Test for independence of residuals
            logCpsqboxtest <- Box.test(logCpres^2, lag=lblag, type='Ljung-Box', fitdf=npar) # Test for independence of residuals
            logCpshapiro <- shapiro.test(logCpres) # Test for normality of residuals
            logCpbias <- t.test(logCpres) # Test for bias of residuals
            if(!'stats' %in% names(rep)) rep$stats <- list()
            rep$stats$acfC.p <- min(acf.signf(logCpres, lag.max=4, return.p=TRUE))
            #rep$stats$ljungboxC.p <- logCpboxtest$p.value
            #rep$stats$ljungboxCp5.p <- logCpp5boxtest$p.value
            #rep$stats$ljungboxCsq.p <- logCpsqboxtest$p.value
            rep$stats$shapiroC.p <- logCpshapiro$p.value
            rep$stats$biasC.p <- logCpbias$p.value
        } else {
            cat('Warning: only', nnotna, 'non-NAs found in catch residuals\n')
            logCpbias <- NA
            logCpshapiro <- NA
        }
        # Indices
        logIpres <- list()
        logIpboxtest <- list()
        logIpp5boxtest <- list()
        logIpsqboxtest <- list()
        logIpshapiro <- list()
        logIpbias <- list()
        for(i in 1:inp$nindex){
            logIpres[[i]] <- rep$osarI[[i]]$residual
            logIpres[[i]][1] <- NA # Always omit first residual because it can be difficult to calculate
            nam <- paste0('acfI', i, '.p')
            rep$stats[[nam]] <- min(acf.signf(logIpres[[i]], lag.max=4, return.p=TRUE))
            nna <- sum(is.na(logIpres[[i]]))
            if(nna > 5) cat('Warning:', nna, 'NAs found in index', i, 'residuals\n')
            nnotna <- sum(!is.na(logIpres[[i]]))
            if(nnotna > 5){
                #logIpboxtest[[i]] <- Box.test(logIpres[[i]], lag=lblag, type='Ljung-Box', fitdf=npar)
                #logIpp5boxtest[[i]] <- Box.test(logIpres[[i]]^2, lag=lblag+4, type='Ljung-Box', fitdf=npar)
                #logIpsqboxtest[[i]] <- Box.test(logIpres[[i]]^2, lag=lblag, type='Ljung-Box', fitdf=npar)
                logIpshapiro[[i]] <- shapiro.test(logIpres[[i]])
                logIpbias[[i]] <- t.test(logIpres[[i]])
                nam <- paste0('ljungboxI', i, '.p')
                #rep$stats[[nam]] <- logIpboxtest[[i]]$p.value
                nam <- paste0('ljungboxIp5', i, '.p')
                #rep$stats[[nam]] <- logIpp5boxtest[[i]]$p.value
                nam <- paste0('ljungboxIsq', i, '.p')
                #rep$stats[[nam]] <- logIpsqboxtest[[i]]$p.value
                nam <- paste0('shapiroI', i, '.p')
                rep$stats[[nam]] <- logIpshapiro[[i]]$p.value
                nam <- paste0('biasI', i, '.p')
                rep$stats[[nam]] <- logIpbias[[i]]$p.value
            } else {
                cat('Warning: only', nnotna, 'non-NAs found in index', i, 'residuals\n')
                logIpshapiro[[i]] <- NA
                logIpbias[[i]] <- NA
            }
        }
        rep$osar <- list(timeC=timeC, logCpres=logCpres, logCpbias=logCpbias, logCpshapiro=logCpshapiro, timeI=timeI, logIpres=logIpres, logIpshapiro=logIpshapiro, logIpbias=logIpbias)
    } else {
        cat('Error: Could not calculate OSA residuals.\n')
    }
    return(rep)
}

#' @name summary.spictcls
#' @title Output a summary of a fit.spict() run.
#' @details The output includes, the convergence message from the optimiser, the likelihood value of the parameters, the parameter estimates with 95% confidence intervals, estimates of derived parameters (BMsy, Fmsy, MSY) with 95% confidence intervals, and predictions of biomass, fishing mortality, and catch for the value of inp$dtpred.
#' @param object A result report as generated by running fit.spict.
#' @param numdigits Present values with this number of digits after the dot.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' summary(rep)
#' @export
summary.spictcls <- function(object, numdigits=8){
    # Set number of decimals
    #options("scipen"=-100, "digits"=numdigits)
    #options("scipen"=-3)
    rep <- object
    cat(paste('Convergence: ', rep$opt$convergence, '  MSG: ', rep$opt$message, '\n', sep=''))
    if(rep$opt$convergence>0) cat('WARNING: Model did not obtain proper convergence! Estimates and uncertainties are most likely invalid and cannot be trusted.\n')
    if('sderr' %in% names(rep)) cat('WARNING: Could not calculate standard deviations. The optimum found may be invalid. Proceed with caution.\n')
    cat(paste('Negative log likelihood: ', round(rep$opt$objective, numdigits), '\n', sep=''))
    cat('\nFit statistics\n')
    statout <- unlist(rep$stats)
    inds <- grep('.p', names(statout))
    sig <- which(statout[inds]<0.05)
    names(statout)[inds][sig] <- paste0('*', names(statout)[inds][sig])
    cat('', paste(capture.output(statout),' \n'))
    # Priors
    npriors <- length(rep$inp$priors)
    useflags <- numeric(npriors)
    for(i in 1:npriors) useflags[i] <- rep$inp$priors[[i]][3]
    inds <- which(useflags==1)
    if(length(inds)>0){
        usepriors <- names(rep$inp$priors)[inds]
        cat(paste('\nPriors on:', paste(usepriors, collapse=', '), '\n'))
    }
    # Model parameters
    cat('\nModel parameter estimates w 95% CI \n')
    sd <- sqrt(diag(rep$cov.fixed))
    nms <- names(rep$par.fixed)
    loginds <- grep('log', nms)
    logp1inds <- grep('logp1',nms)
    logitinds <- grep('logit',nms)
    loginds <- setdiff(loginds, c(logp1inds, logitinds))
    est <- rep$par.fixed
    est[loginds] <- exp(est[loginds])
    est[logitinds] <- invlogit(est[logitinds])
    est[logp1inds] <- invlogp1(est[logp1inds])
    cilow <- rep$par.fixed-1.96*sd
    cilow[loginds] <- exp(cilow[loginds])
    cilow[logitinds] <- invlogit(cilow[logitinds])
    cilow[logp1inds] <- invlogp1(cilow[logp1inds])
    ciupp <- rep$par.fixed+1.96*sd
    ciupp[loginds] <- exp(ciupp[loginds])
    ciupp[logitinds] <- invlogit(ciupp[logitinds])
    ciupp[logp1inds] <- invlogp1(ciupp[logp1inds])
    if('true' %in% names(rep$inp)){
        npar <- length(nms)
        unms <- unique(nms)
        nupar <- length(unms)
        truepar <- NULL
        for(i in 1:nupar) truepar <- c(truepar, rep$inp$true[[unms[i]]])
        truepar[loginds] <- exp(truepar[loginds])
        truepar[logitinds] <- invlogit(truepar[logitinds])
        truepar[logp1inds] <- invlogp1(truepar[logp1inds])
        ci <- rep(0, npar)
        for(i in 1:npar) ci[i] <- as.numeric(truepar[i] > cilow[i] & truepar[i] < ciupp[i])
        resout <- cbind(estimate=round(est,numdigits), true=round(truepar,numdigits), cilow=round(cilow,numdigits), ciupp=round(ciupp,numdigits), true.in.ci=ci, est.in.log=round(rep$par.fixed,numdigits))
    } else {
        resout <- cbind(estimate=round(est,numdigits), cilow=round(cilow,numdigits), ciupp=round(ciupp,numdigits), est.in.log=round(rep$par.fixed,numdigits))
    }
    #nms[loginds] <- substr(names(rep$par.fixed[loginds]),4,60)
    nms[loginds] <- sub('log', '', names(rep$par.fixed[loginds]))
    nms[logitinds] <- sub('logit', '', names(rep$par.fixed[logitinds]))
    nms[logp1inds] <- sub('logp1', '', names(rep$par.fixed[logp1inds]))
    unms <- unique(nms)
    for(inm in unms){
        nn <- sum(inm==nms)
        if(nn>1){
            newnms <- paste0(inm, 1:nn)
            inds <- which(inm==nms)
            nms[inds] <- newnms
        }
    }
    rownames(resout) <- nms
    colnms <- c('estimate', 'cilow', 'ciupp', 'est.in.log')
    cat('', paste(capture.output(resout),' \n'))
    if(!'sderr' %in% names(rep)){
        # Derived estimates
        cat(paste0('\nDerived estimates w 95% CI\n'))
        derout <- rbind(get.par(parname='logr', rep, exp=TRUE)[, c(2,1,3,2)])
                        #get.par(parname='logq', rep, exp=TRUE)[c(2,1,3,2)])
        derout[, 4] <- log(derout[, 4])
        derout <- round(derout, numdigits)
        colnames(derout) <- colnms
        #rownames(derout) <- rep('r    ', dim(derout)[1])
        if(dim(derout)[1]>1 & 'yearsepgrowth' %in% names(rep$inp)){
            rownames(derout) <- c('r     ', paste0('r', rep$inp$yearsepgrowth))
        } else {
            rownames(derout) <- paste0('r', each=paste0(1:dim(derout)[1], '    '))
        }
        cat('', paste(capture.output(derout),' \n'))
        cat(' Deterministic reference points\n')
        derout <- rbind(get.par(parname='logBmsyd', rep, exp=TRUE)[,c(2,1,3,2)],
                        get.par(parname='logFmsyd', rep, exp=TRUE)[,c(2,1,3,2)],
                        get.par(parname='logMSYd', rep, exp=TRUE)[,c(2,1,3,2)])
        derout[, 4] <- log(derout[, 4])
        derout <- round(derout, numdigits)
        colnames(derout) <- colnms
        nr <- length(rep$inp$ini$logr)
        if(nr > 1){
            rownames(derout) <- c(t(outer(c('Bmsyd', 'Fmsyd', 'MSYd'), 1:2, paste0)))
        } else {
            rownames(derout) <- c('Bmsyd', 'Fmsyd', 'MSYd')
        }
        if('true' %in% names(rep$inp)){
            trueder <- c(rep$inp$true$Bmsyd, rep$inp$true$Fmsyd, rep$inp$true$MSYd)
            cider <- rep(0, 3)
            for(i in 1:3) cider[i] <- as.numeric(trueder[i] > derout[i, 2] & trueder[i] < derout[i, 3])
            derout <- cbind(estimate=derout[, 1], true=round(trueder,numdigits), derout[, 2:3], true.in.ci=cider, est.in.log=derout[, 4])
            derout <- cbind(derout[, 1], round(trueder,numdigits), derout[, 2:3], cider, derout[, 4])
            colnames(derout) <- c(colnms[1], 'true', colnms[2:3], 'true.in.ci', colnms[4])
        }
        cat('', paste(capture.output(derout),' \n'))
        # Stochastic derived estimates
        cat(' Stochastic reference points\n')
        derout <- rbind(get.par(parname='logBmsys', rep, exp=TRUE)[,c(2,1,3,2)],
                        get.par(parname='logFmsys', rep, exp=TRUE)[,c(2,1,3,2)],
                        get.par(parname='logMSYs', rep, exp=TRUE)[,c(2,1,3,2)])
        derout[, 4] <- log(derout[, 4])
        derout <- round(derout, numdigits)
        colnames(derout) <- colnms
        if(nr > 1){
            rownames(derout) <- c(t(outer(c('Bmsys', 'Fmsys', 'MSYs'), 1:2, paste0)))
        } else {
            rownames(derout) <- c('Bmsys', 'Fmsys', 'MSYs')
        }
        if('true' %in% names(rep$inp)){
            trueder <- c(rep$inp$true$Bmsy, rep$inp$true$Fmsy, rep$inp$true$MSY)
            cider <- rep(0, 3)
            for(i in 1:3) cider[i] <- as.numeric(trueder[i] > derout[i, 2] & trueder[i] < derout[i, 3])
            #derout <- cbind(estimate=derout[, 1], true=round(trueder,numdigits), derout[, 2:3], true.in.ci=cider, est.in.log=derout[, 4])
            derout <- cbind(derout[, 1], round(trueder,numdigits), derout[, 2:3], cider, derout[, 4])
            colnames(derout) <- c(colnms[1], 'true', colnms[2:3], 'true.in.ci', colnms[4])

        }
        cat('', paste(capture.output(derout),' \n'))
        # States
        cat(paste0('\nStates w 95% CI (inp$msytype: ', rep$inp$msytype, ')\n'))
        stateout <- rbind(
            get.par(parname='logBl', rep, exp=TRUE)[c(2,1,3,2)],
            get.par(parname='logFl', rep, exp=TRUE)[c(2,1,3,2)],
            get.par(parname='logBlBmsy', rep, exp=TRUE)[c(2,1,3,2)],
            get.par(parname='logFlFmsy', rep, exp=TRUE)[c(2,1,3,2)])
        stateout[, 4] <- log(stateout[, 4])
        stateout <- round(stateout, numdigits)
        colnames(stateout) <- colnms
        #et <- tail(rep$inp$time[rep$inp$indest],1)
        et <- rep$inp$time[rep$inp$indlastobs]
        rownames(stateout) <- c(paste0('B_',et), paste0('F_',et), paste0('B_',et,'/Bmsy'), paste0('F_',et,'/Fmsy'))
        cat('', paste(capture.output(stateout),' \n'))
        # Predictions
        cat(paste0('\nPredictions w 95% CI (inp$msytype: ', rep$inp$msytype, ')\n'))
        predout <- rbind(
            get.par(parname='logBp', rep, exp=TRUE)[c(2,1,3,2)],
            get.par(parname='logFp', rep, exp=TRUE)[c(2,1,3,2)],
            get.par(parname='logBpBmsy', rep, exp=TRUE)[c(2,1,3,2)],
            get.par(parname='logFpFmsy', rep, exp=TRUE)[c(2,1,3,2)],
            tail(get.par(parname='logCpred', rep, exp=TRUE),1)[c(2,1,3,2)])
        #        get.par(parname='logCp', rep, exp=TRUE)[c(2,1,3,2)])
        predout[, 4] <- log(predout[, 4])
        predout <- round(predout, numdigits)
        colnames(predout) <- c('prediction', colnms[2:4])
        et <- rep$inp$time[rep$inp$dtprediind]
        rownames(predout) <- c(paste0('B_',et), paste0('F_',et), paste0('B_',et,'/Bmsy'), paste0('F_',et,'/Fmsy'), paste0('Catch_',tail(rep$inp$timeCpred,1)))
        if(rep$inp$dtpredc == 0) predout <- predout[-dim(predout)[1], ]
        cat('', paste(capture.output(predout),' \n'))
    }
    #if('osar' %in% names(rep)){
    #    cat('\nOne-step-ahead residuals - Ljung-box test for independence of lag 1\n')
    #    cat(paste(' Catches p-value:', round(rep$osar$logCpboxtest$p.value, numdigits), '\n'))
    #    for(i in 1:rep$inp$nindex) cat(paste(' Index', i, 'p-value:', round(rep$osar$logIpboxtest[[i]]$p.value, numdigits), '\n'))
    #}
}

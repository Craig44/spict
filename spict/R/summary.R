#' @name summary.spictcls
#' @title Output a summary of a fit.spict() run.
#' @details The output includes, the convergence message from the optimiser, the likelihood value of the parameters, the parameter estimates with 95% confidence intervals, estimates of derived parameters (BMsy, Fmsy, MSY) with 95% confidence intervals, and predictions of biomass, fishing mortality, and catch for the value of inp$dtpred.
#' @param object A result report as generated by running fit.spict.
#' @param numdigits Present values with this number of digits after the dot.
#' @return Nothing.
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' summary(rep)
#' @export
summary.spictcls <- function(object, numdigits=8){
    # Set number of decimals
    #options("scipen"=-100, "digits"=numdigits)
    #options("scipen"=-3)
    order <- c(2,1,3,2)
    rep <- object
    cat(paste('Convergence: ', rep$opt$convergence, '  MSG: ', rep$opt$message, '\n', sep=''))
    if(rep$opt$convergence>0){
        cat('WARNING: Model did not obtain proper convergence! Estimates and uncertainties are most likely invalid and cannot be trusted.\n')
        grad <- rep$obj$gr()
        names(grad) <- names(rep$par.fixed)
        cat('Gradient at current parameter vector\n')
        cat('', paste(capture.output(grad),' \n'))
        cat('\n')
    }
    if('sderr' %in% names(rep)) cat('WARNING: Could not calculate standard deviations. The optimum found may be invalid. Proceed with caution.\n')
    cat(paste('Negative log likelihood: ', round(rep$opt$objective, numdigits), '\n', sep=''))
    cat(paste0('\nNobs C: ', rep$inp$nobsC, paste0(paste0(',  Nobs I', 1:rep$inp$nindex), ': ', rep$inp$nobsI, collapse=''), '\n'))
    cat('Fit statistics\n')
    statout <- unlist(rep$stats)
    inds <- grep('.p', names(statout))
    sig <- which(statout[inds]<0.05)
    names(statout)[inds][sig] <- paste0('*', names(statout)[inds][sig])
    cat('', paste(capture.output(statout),' \n'))
    # Priors
    inds <- which(rep$inp$priorsuseflag==1)
    if(length(inds)>0){
        usepriors <- names(rep$inp$priors)[inds]
        if('logB' %in% usepriors){
            inds <- which(usepriors == 'logB')
            for(i in 1:length(inds)) usepriors[inds[i]] <- paste0(usepriors[inds[i]], rep$inp$priors[[i]][4])
        }
        cat(paste('\nPriors on:', paste(usepriors, collapse=', '), '\n'))
    }
    # Catch/biomass unit
    if(rep$inp$catchunit != ''){
        cat(paste('Catch/biomass unit:', rep$inp$catchunit, '\n'))
    }
    # Model parameters
    cat('\nModel parameter estimates w 95% CI \n')
    sd <- sqrt(diag(rep$cov.fixed))
    nms <- names(rep$par.fixed)
    loginds <- grep('log', nms)
    logp1inds <- grep('logp1',nms)
    logitinds <- grep('logit',nms)
    loginds <- setdiff(loginds, c(logp1inds, logitinds))
    est <- rep$par.fixed
    est[loginds] <- exp(est[loginds])
    est[logitinds] <- invlogit(est[logitinds])
    est[logp1inds] <- invlogp1(est[logp1inds])
    cilow <- rep$par.fixed-1.96*sd
    cilow[loginds] <- exp(cilow[loginds])
    cilow[logitinds] <- invlogit(cilow[logitinds])
    cilow[logp1inds] <- invlogp1(cilow[logp1inds])
    ciupp <- rep$par.fixed+1.96*sd
    ciupp[loginds] <- exp(ciupp[loginds])
    ciupp[logitinds] <- invlogit(ciupp[logitinds])
    ciupp[logp1inds] <- invlogp1(ciupp[logp1inds])
    if('true' %in% names(rep$inp)){
        npar <- length(nms)
        unms <- unique(nms)
        nupar <- length(unms)
        truepar <- NULL
        parnotest <- NULL
        for(i in 1:nupar){
            tp <- rep$inp$true[[unms[i]]]
            nestpar <- sum(names(est) == unms[i])
            truepar <- c(truepar, tp[1:nestpar])
            if(nestpar < length(tp)){
                inds <- (nestpar+1):length(tp)
                parnotest <- c(parnotest, tp[inds])
                names(parnotest) <- c(names(parnotest), paste0(unms[i], inds))
            }
        }
        truepar[loginds] <- exp(truepar[loginds])
        truepar[logitinds] <- invlogit(truepar[logitinds])
        truepar[logp1inds] <- invlogp1(truepar[logp1inds])
        ci <- rep(0, npar)
        for(i in 1:npar) ci[i] <- as.numeric(truepar[i] > cilow[i] & truepar[i] < ciupp[i])
        resout <- cbind(estimate=round(est,numdigits), true=round(truepar,numdigits), cilow=round(cilow,numdigits), ciupp=round(ciupp,numdigits), true.in.ci=ci, est.in.log=round(rep$par.fixed,numdigits))
    } else {
        resout <- cbind(estimate=round(est,numdigits), cilow=round(cilow,numdigits), ciupp=round(ciupp,numdigits), est.in.log=round(rep$par.fixed,numdigits))
    }
    #nms[loginds] <- substr(names(rep$par.fixed[loginds]),4,60)
    nms[loginds] <- sub('log', '', names(rep$par.fixed[loginds]))
    nms[logitinds] <- sub('logit', '', names(rep$par.fixed[logitinds]))
    nms[logp1inds] <- sub('logp1', '', names(rep$par.fixed[logp1inds]))
    unms <- unique(nms)
    for(inm in unms){
        nn <- sum(inm==nms)
        if(nn>1){
            newnms <- paste0(inm, 1:nn)
            inds <- which(inm==nms)
            nms[inds] <- newnms
        }
    }
    rownames(resout) <- nms
    colnms <- c('estimate', 'cilow', 'ciupp', 'est.in.log')
    cat('', paste(capture.output(resout),' \n'))
    if('true' %in% names(rep$inp)){
        #if(!is.null(parnotest)) cat(paste('\nPars not estimated:', paste(names(parnotest), collapse=', '), '\n'))
    }
    if(!'sderr' %in% names(rep)){
        # Derived estimates
        cat(paste0('\nDerived estimates w 95% CI\n'))
        derout <- rbind(get.par(parname='logr', rep, exp=TRUE)[, order])
        derout[, 4] <- log(derout[, 4])
        derout <- round(derout, numdigits)
        colnames(derout) <- colnms
        if(dim(derout)[1]>1 & 'yearsepgrowth' %in% names(rep$inp)){
            rownames(derout) <- c('r     ', paste0('r', rep$inp$yearsepgrowth))
        } else {
            rownames(derout) <- paste0('r', each=paste0(1:dim(derout)[1], '    '))
        }
        cat('', paste(capture.output(derout),' \n'))
        # Deterministic ref points
        cat(' Deterministic reference points\n')
        derout <- rbind(get.par(parname='logBmsyd', rep, exp=TRUE)[,order],
                        get.par(parname='logFmsyd', rep, exp=TRUE)[,order],
                        get.par(parname='logMSYd', rep, exp=TRUE)[,order])
        derout[, 4] <- log(derout[, 4])
        derout <- round(derout, numdigits)
        colnames(derout) <- colnms
        nr <- length(rep$inp$ini$logr)
        if(nr > 1){
            rownames(derout) <- c(t(outer(c('Bmsyd', 'Fmsyd', 'MSYd'), 1:2, paste0)))
        } else {
            rownames(derout) <- c('Bmsyd', 'Fmsyd', 'MSYd')
        }
        if('true' %in% names(rep$inp)){
            trueder <- c(rep$inp$true$Bmsyd, rep$inp$true$Fmsyd, rep$inp$true$MSYd)
            cider <- numeric(3)
            for(i in 1:3) cider[i] <- as.numeric(trueder[i] > derout[i, 2] & trueder[i] < derout[i, 3])
            derout <- cbind(derout[, 1], round(trueder,numdigits), derout[, 2:3], cider, derout[, 4])
            colnames(derout) <- c(colnms[1], 'true', colnms[2:3], 'true.in.ci', colnms[4])
        }
        cat('', paste(capture.output(derout),' \n'))
        # Stochastic derived estimates
        cat(' Stochastic reference points\n')
        derout <- rbind(get.par(parname='logBmsys', rep, exp=TRUE)[,order],
                        get.par(parname='logFmsys', rep, exp=TRUE)[,order],
                        get.par(parname='logMSYs', rep, exp=TRUE)[,order])
        derout[, 4] <- log(derout[, 4])
        derout <- round(derout, numdigits)
        colnames(derout) <- colnms
        if(nr > 1){
            rownames(derout) <- c(t(outer(c('Bmsys', 'Fmsys', 'MSYs'), 1:2, paste0)))
        } else {
            rownames(derout) <- c('Bmsys', 'Fmsys', 'MSYs')
        }
        if('true' %in% names(rep$inp)){
            trueder <- c(rep$inp$true$Bmsy, rep$inp$true$Fmsy, rep$inp$true$MSY)
            cider <- rep(0, 3)
            for(i in 1:3) cider[i] <- as.numeric(trueder[i] > derout[i, 2] & trueder[i] < derout[i, 3])
            derout <- cbind(derout[, 1], round(trueder,numdigits), derout[, 2:3], cider, derout[, 4])
            colnames(derout) <- c(colnms[1], 'true', colnms[2:3], 'true.in.ci', colnms[4])
        }
        cat('', paste(capture.output(derout),' \n'))
        # States
        cat(paste0('\nStates w 95% CI (inp$msytype: ', rep$inp$msytype, ')\n'))
        stateout <- rbind(
            get.par(parname='logBl', rep, exp=TRUE)[order],
            get.par(parname='logFl', rep, exp=TRUE)[order],
            get.par(parname='logBlBmsy', rep, exp=TRUE)[order],
            get.par(parname='logFlFmsy', rep, exp=TRUE)[order])
        stateout[, 4] <- log(stateout[, 4])
        stateout <- round(stateout, numdigits)
        colnames(stateout) <- colnms
        #et <- tail(rep$inp$time[rep$inp$indest],1)
        et <- rep$inp$time[rep$inp$indlastobs]
        rownames(stateout) <- c(paste0('B_',et), paste0('F_',et), paste0('B_',et,'/Bmsy'), paste0('F_',et,'/Fmsy'))
        cat('', paste(capture.output(stateout),' \n'))
        # Predictions
        cat(paste0('\nPredictions w 95% CI (inp$msytype: ', rep$inp$msytype, ')\n'))
        EBinf <- get.EBinf(rep)
        predout <- rbind(
            get.par(parname='logBp', rep, exp=TRUE)[order],
            get.par(parname='logFp', rep, exp=TRUE)[order],
            get.par(parname='logBpBmsy', rep, exp=TRUE)[order],
            get.par(parname='logFpFmsy', rep, exp=TRUE)[order],
            tail(get.par(parname='logCpred', rep, exp=TRUE),1)[order],
            c(EBinf, NA, NA, EBinf))
        predout[, 4] <- log(predout[, 4])
        predout <- round(predout, numdigits)
        colnames(predout) <- c('prediction', colnms[2:4])
        et <- rep$inp$time[rep$inp$dtprediind]
        rownames(predout) <- c(paste0('B_',et), paste0('F_',et), paste0('B_',et,'/Bmsy'), paste0('F_',et,'/Fmsy'), paste0('Catch_',tail(rep$inp$timeCpred,1)), 'B_inf')
        if(rep$inp$dtpredc == 0) predout <- predout[-dim(predout)[1], ]
        cat('', paste(capture.output(predout),' \n'))
    }
}



